var tipuesearch = {"pages":[{"text":"JSON-Fortran Brief description License Official Releases Miscellaneous Brief description A user-friendly and object-oriented API for reading and writing JSON files, written in\nmodern Fortran (Fortran 2003+).  The source code is a single Fortran module file\n( json_module.F90 ). License The JSON -Fortran source code and related files and documentation are\ndistributed under a permissive free software license (BSD-style).  See\nthe LICENSE file for more details. Official Releases The current stable release is 4.2.0 and can be downloaded\non GitHub or installed with Homebrew on Mac OSX. The\ndocumentation for the current version, 4.2.0 , can be\nfound here 1 , and a\nlist of changes from the previous version are here . A list of all past releases, links to their documentation, and the\nchage log can be found on the releases page . Miscellaneous For more information about JSON , see: http://www.json.org/ Documentation for a particular release does not contain links\nback to general documentation; use the browser's back button to\nnavigate back to http://jacobwilliams.github.io/json-fortran/ ↩ Developer Info Jacob Williams","tags":"","loc":"index.html","title":" JSON-Fortran "},{"text":"Source Code !***************************************************************************************** !> ! Module for the first unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_1_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename1 = 'test1.json' contains subroutine test_1 ( error_cnt ) !! Read a sample JSON file and retrieve some data from it implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval logical :: found type ( json_value ), pointer :: p error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 1' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file ' // dir // filename1 call json % load_file ( filename = dir // filename1 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the file...' write ( output_unit , '(A)' ) '{ \"part a\" :' !Wrap 3 outputs to make stdout valid json call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'get some data from the file...' write ( error_unit , '(A)' ) '' call json % get ( 'version.svn' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,I5)' ) 'version.svn = ' , ival end if write ( error_unit , '(A)' ) '' call json % get ( 'data(1).array(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'data(1).array(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(1)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(1) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(3)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(3) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'data(2).real' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,E30.16)' ) 'data(2).real = ' , rval end if write ( error_unit , '(A)' ) '' call json % get ( 'files[4]' , cval ) !has hex characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[4] = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files[5]' , cval ) !string with spaces and no escape characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[5] = ' // trim ( cval ) end if ! ! Test of values that aren't there: ! Note: when using the \"found\" output, the exceptions are cleared automatically. ! write ( error_unit , '(A)' ) '' call json % get ( 'files[10]' , cval , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'files[10] not in file.' else write ( error_unit , '(1x,A)' ) 'files[10] = ' // trim ( cval ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' call json % get ( 'version.blah' , ival , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'version.blah not in file.' else write ( error_unit , '(A)' ) 'version.blah = ' , ival error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test removing data from the json structure:' call json % get ( 'files' , p ) !in the middle of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(1).array' , p ) !at the end of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(2).number' , p ) !at the beginning of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part b\" : ' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test replacing data from the json structure:' call json % get ( 'data(1)' , p ) call json_update ( p , 'name' , 'Cuthbert' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !call json%get('data(2)', p) !call json_update(p,'real',[1.0_wp, 2.0_wp, 3.0_wp],found)   !don't have one like this yet... !use the json_file procedure to update a variable: call json % update ( 'version.svn' , 999 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part c\" : ' call json % print_file () write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_1 end module jf_test_1_mod !***************************************************************************************** !***************************************************************************************** program jf_test_1 !! First unit test. use jf_test_1_mod , only : test_1 implicit none integer :: n_errors n_errors = 0 call test_1 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_1 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_1.f90.html","title":"jf_test_1.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 3/10/2015 ! ! Module for the tenth unit test. module jf_test_10_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: filename = 'test1.json' character ( len =* ), parameter :: dir = '../files/inputs/' !working directory contains subroutine test_10 ( error_cnt ) !! Test some of the lesser-used features of the library implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = 256 ), dimension (:), allocatable :: str_vec type ( json_file ) :: f , f2 type ( json_value ), pointer :: p character ( kind = CK , len = :), allocatable :: str , name logical :: found , lval integer :: var_type , n_children character ( kind = CDK , len =* ), parameter :: json_str = '{ \"blah\": 123 }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 10 ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) // '...' call f % load_file ( dir // filename ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_move_pointer...' call f2 % move ( f ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_load_from_string...' call f % load_from_string ( json_str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_print_to_string...' call f % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_variable_info...' call f % info ( 'blah' , found , var_type , n_children ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( var_type == json_integer . and . n_children == 0 ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error invalid values:' , var_type , n_children error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_get_logical...' call f2 % get ( 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . lval ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result.' error_cnt = error_cnt + 1 end if end if ! json_file_get_logical_vec .... [add this] write ( error_unit , '(A)' ) 'json_file_get_string_vec...' call f2 % get ( 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable present]...' call f2 % update ( 'data(1).tf1' ,. false ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable not present]...' call f2 % update ( 'new_logical' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_real [variable present]...' call f2 % update ( 'data[2].real' , 10 0.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_real [variable not present]...' call f2 % update ( 'new_real' , 177 6.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_string [variable present]...' call f2 % update ( 'version.string' , '10.0.0' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_string [variable not present]...' call f2 % update ( 'new_string' , 'foo' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_get_integer...' call f2 % get ( '$' , p , found ) !get root if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' write ( error_unit , '(A)' ) 'json_info...' call json_info ( p , var_type , n_children , name ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_remove_if_present...' call json_remove_if_present ( p , 'version.patch' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_logical...' call json_update ( p , 'data(1).tf1' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_double...' call json_update ( p , 'data(2).real' , - 1.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_logical...' call json_get ( p , 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_string_vec...' call json_get ( p , 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_create...' write ( error_unit , '(A)' ) 'json_create_logical...' ; call json_destroy ( p ); call json_create_logical ( p ,. true ., 'foo' ) write ( error_unit , '(A)' ) 'json_create_integer...' ; call json_destroy ( p ); call json_create_integer ( p , 1000 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_double ...' ; call json_destroy ( p ); call json_create_double ( p , 9.0 d0 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_string ...' ; call json_destroy ( p ); call json_create_string ( p , 'foo' , 'bar' ) write ( error_unit , '(A)' ) 'json_create_null   ...' ; call json_destroy ( p ); call json_create_null ( p , 'foo' ) write ( error_unit , '(A)' ) 'json_create_object ...' ; call json_destroy ( p ); call json_create_object ( p , 'foo' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- !cleanup: !call f%destroy()   !WARNING: causing \"pointer being freed was not allocated\" errors.... need to investigate !call f2%destroy() end subroutine test_10 end module jf_test_10_mod !***************************************************************************************** !***************************************************************************************** program jf_test_10 !! Tenth unit test. use jf_test_10_mod , only : test_10 implicit none integer :: n_errors n_errors = 0 call test_10 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_10 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_10.f90.html","title":"jf_test_10.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Izaak Beekman !  date: 3/13/2015 ! ! Module for the 11th unit test to test unicode support if enabled. module jf_test_11_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory # ifdef USE_UCS4 character ( len =* ), parameter :: unicode_file = 'hello-world-ucs4.json' #endif character ( len =* ), parameter :: ascii_equivalent = 'hello-world-ascii.json' contains subroutine test_11 ( error_cnt ) !! Read the file and extract some data from it. implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = :), allocatable :: cval type ( json_file ) :: json !the JSON structure read from the file: # ifdef USE_UCS4 type ( json_file ) :: clone # endif error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 11' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' # ifdef USE_UCS4 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // unicode_file call json % load_file ( filename = dir // unicode_file ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' call clone % load_from_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call clone % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // unicode_file // '\"' call clone % print_file ( '../files/' // unicode_file ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call clone % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if # endif ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // ascii_equivalent write ( error_unit , '(A)' ) 'This is the ascii equivalent of \"../files/inputs/hello-world-ucs4.json\"' call json % load_file ( filename = dir // ascii_equivalent ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call json % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // ascii_equivalent // '\"' call json % print_file ( '../files/' // ascii_equivalent ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_11 end module jf_test_11_mod !***************************************************************************************** !***************************************************************************************** program jf_test_11 !! 11th unit test. use jf_test_11_mod , only : test_11 implicit none integer :: n_errors n_errors = 0 call test_11 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_11 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_11.f90.html","title":"jf_test_11.F90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Izaak Beekman !  date: 07/27/2015 ! ! Module for the 12th unit test. module jf_test_12_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! Path to write JSON file to character ( len =* ), parameter :: file = 'test12.json' !! Filename to write real ( wp ), parameter :: TOL = 100 * epsilon ( 1.0_wp ) !! Tolerance for real comparisons contains subroutine test_12 ( error_cnt ) implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller integer , parameter :: imx = 5 , jmx = 3 , kmx = 4 !! dimensions for raw work array of primitive type integer , dimension ( 3 ) :: shape !! shape of work array integer , dimension (:), allocatable :: fetched_shape !! retrieved shape type ( json_value ), pointer :: root , meta_array !! json nodes to work with type ( json_value ), pointer :: tmp_json_ptr type ( json_file ) :: my_file real ( wp ), dimension ( imx , jmx , kmx ) :: raw_array !! raw work array real ( wp ) :: array_element real ( wp ), dimension (:), allocatable :: fetched_array character ( kind = CK , len = :), allocatable :: description integer :: i , j , k !! loop indices integer :: array_length , lun logical :: existed logical , dimension (:), allocatable :: SOS error_cnt = 0 call json_initialize ( verbose = . true ., real_format = 'G' ) call check_errors () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 12' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! populate the raw array forall ( i = 1 : imx , j = 1 : jmx , k = 1 : kmx ) ! could use size(... , dim=...) instead of constants raw_array ( i , j , k ) = i + ( j - 1 ) * imx + ( k - 1 ) * imx * jmx end forall call json_create_object ( root , dir // file ) call check_errors () call json_create_object ( meta_array , 'array data' ) call check_errors () shape = [ size ( raw_array , dim = 1 ), size ( raw_array , dim = 2 ), size ( raw_array , dim = 3 )] call json_add ( meta_array , 'shape' , shape ) call check_errors () call json_add ( meta_array , 'total size' , size ( raw_array )) call check_errors () call json_update ( meta_array , 'total size' , size ( raw_array ), found = existed ) call check_errors ( existed ) call json_add ( meta_array , CK_ 'description' , 'test data' ) call check_errors () ! now add the array ! N.B. `json_add()` only accepts 1-D arrays and scalars, so transform with `reshape` ! N.B. reshape populates new array in \"array element order\". ! C.F. \"Modern Fortran Explained\", by Metcalf, Cohen and Reid, p. 24. ! N.B. Fortran is a column major language call json_add ( meta_array , 'data' , reshape ( raw_array , [ size ( raw_array ) ] ) ) call check_errors () ! now put it all together call json_add ( root , meta_array ) call check_errors () write ( error_unit , '(A)' ) \"Print the JSON object to stderr:\" call json_print ( root , error_unit ) call check_errors () call json_get ( root , '$.array data.data(1)' , array_element ) call check_errors ( abs ( array_element - 1.0_wp ) <= TOL ) call json_get ( root , '@.array data.shape' , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_update ( meta_array , 'description' , CK_ 'Test Data' , found = existed ) call check_errors ( existed ) call json_update ( meta_array , CK_ 'description' , 'Test data' , found = existed ) call check_errors ( existed ) call json_get ( meta_array , 'description' , description ) call check_errors ( 'Test data' == description ) call json_get ( root , 'array data.total size' , array_length ) call check_errors ( array_length == imx * jmx * kmx ) sos = [. true ., . true ., . true ., & . false ., . false ., . false ., & . true ., . true ., . true .] call json_add ( root , 'SOS' , sos ) call check_errors () call json_get ( root , 'SOS' , sos ) call check_errors () call json_add ( root , 'vector string' , [ CK_ 'only one value' ]) call check_errors () call json_add ( root , CK_ 'page' , [ 'The quick brown fox     ' , 'jumps over the lazy dog.' ]) call check_errors () call json_get ( root , 'SOS' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , sos ) call check_errors () call json_get ( meta_array , 'shape' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_get ( meta_array , 'data' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call json_get ( root , 'array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) raw_array = 0 call json_get ( me = root , path = 'array data.data' , array_callback = get_3D_from_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) my_file = json_file ( root ) call my_file % update ( 'array data.description' , CK_ 'vector data' , found = existed ) call check_errors ( existed ) call my_file % update ( CK_ 'array data.description' , 'Vector data' , found = existed ) call check_errors ( existed ) call my_file % get ( 'SOS' , sos ) call check_errors () call my_file % get ( '$array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call my_file % get ( tmp_json_ptr ) call check_errors ( associated ( tmp_json_ptr , root )) open ( file = dir // file , newunit = lun , form = 'formatted' , action = 'write' ) call my_file % print_file ( lun ) call check_errors () close ( lun ) contains subroutine check_errors ( assertion ) logical , optional , intent ( in ) :: assertion if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( present ( assertion )) then if (. not . assertion ) error_cnt = error_cnt + 1 end if end subroutine check_errors subroutine get_3D_from_array ( element , i , count ) type ( json_value ), pointer , intent ( in ) :: element integer , intent ( in ) :: i !!index integer , intent ( in ) :: count !!size of array integer :: useless !! assign count to this to silence warnings ! let's pretend we're c programmers! call json_get ( element , raw_array ( & mod ( i - 1 , imx ) + 1 , & ! i index mod (( i - 1 ) / imx , jmx ) + 1 , & ! j index mod (( i - 1 ) / imx / jmx , kmx ) + 1 ) ) ! k inded useless = count end subroutine get_3D_from_array end subroutine test_12 end module jf_test_12_mod !***************************************************************************************** !***************************************************************************************** program jf_test_12 !! 12th unit test. use jf_test_12_mod , only : test_12 implicit none integer :: n_errors n_errors = 0 call test_12 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_12 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_12.f90.html","title":"jf_test_12.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 09/01/2015 ! ! Module for the 13th unit test. module jf_test_13_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none contains subroutine test_13 ( error_cnt ) !! Tests different real format strings using repeated calls to [[json_initialize]]. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_file ) :: my_file character ( kind = CK , len = :), allocatable :: str integer :: i character ( len = 2 ), dimension ( 4 ), parameter :: fmts = [ 'g ' , 'e ' , 'en' , 'es' ] !! format statements to test write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 13' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 do i = 1 , size ( fmts ) call json_initialize ( real_format = trim ( fmts ( i ))) call my_file % load_from_string ( '{ \"value\": 1234.56789 }' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call my_file % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( output_unit , '(A)' ) str end if call my_file % destroy () end do end subroutine test_13 end module jf_test_13_mod !***************************************************************************************** !***************************************************************************************** program jf_test_13 !! 13th unit test. use jf_test_13_mod , only : test_13 implicit none integer :: n_errors call test_13 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_13 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_13.f90.html","title":"jf_test_13.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 09/02/2015 ! ! Module for the 14th unit test. module jf_test_14_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename1 = 'test1.json' !! the file to read integer :: icount = 0 !! a count of the number of \"name\" variables found contains subroutine test_14 ( error_cnt ) !! Tests the traversal of a JSON structure !! !! It traverses the structure, looks for all \"name\" variables, and changes the name. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_value ), pointer :: json write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 14' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 icount = 0 !number of name changes (should be 2) call json_initialize () !initialize the module call json_parse ( dir // filename1 , json ) !read the file if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_traverse ( json , rename ) !traverse all nodes in the structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( icount /= 2 ) then write ( error_unit , '(A)' ) 'Error: should be 2 \"name\" variables in this file: ' // filename1 error_cnt = error_cnt + 1 end if if ( error_cnt == 0 ) then write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' All names changed to Fred:' write ( error_unit , '(A)' ) '' call json_print ( json , output_unit ) write ( error_unit , '(A)' ) '' end if call json_destroy ( json ) !clean up if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_14 subroutine rename ( p , finished ) !! change all \"name\" variable values to \"Fred\" implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( out ) :: finished integer :: var_type character ( kind = CK , len = :), allocatable :: str logical :: found !get info about this variable: call json_info ( p , var_type = var_type , name = str ) !it must be a string named \"name\": if ( var_type == json_string . and . str == 'name' ) then call json_get ( p , '@' , str ) ! get original name call json_update ( p , '@' , 'Fred' , found ) !change it write ( error_unit , '(A)' ) str // ' name changed' icount = icount + 1 end if !cleanup: if ( allocated ( str )) deallocate ( str ) !always false, since we want to traverse all nodes: finished = . false . end subroutine rename end module jf_test_14_mod !***************************************************************************************** !***************************************************************************************** program jf_test_14 !! 14th unit test. use jf_test_14_mod , only : test_14 implicit none integer :: n_errors call test_14 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_14 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_14.f90.html","title":"jf_test_14.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the second unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_2_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! working directory character ( len =* ), parameter :: filename2 = 'test2.json' contains subroutine test_2 ( error_cnt ) !! Populate a JSON structure and write it to a file. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp , traj integer :: iunit error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 2' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !root: call json_create_object ( p , dir // filename2 ) ! create the value and associate the pointer ! add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'initialize the structure...' !config structure: call json_create_object ( inp , 'inputs' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory structure: call json_create_array ( traj , 'trajectory' ) !an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , traj ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'adding some data to structure...' !add some variables: !input variables: call json_add ( inp , 't0' , 0.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'tf' , 1.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'x0' , 999 9.000_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_scalar' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_scalar' , . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_vector' , [. true ., . false ., . true .]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) !trajectory variables: call add_variables_to_input ( traj , 'Rx' , 'km' , 'J2000' , 'EARTH' , [ 1.0_wp , 2.0_wp , 3.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Ry' , 'km' , 'J2000' , 'EARTH' , [ 1 0.0_wp , 2 0.0_wp , 3 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Rz' , 'km' , 'J2000' , 'EARTH' , [ 10 0.0_wp , 20 0.0 d0 , 30 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vx' , 'km/s' , 'J2000' , 'EARTH' , [ 1.0e-3_wp , 2.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vy' , 'km/s' , 'J2000' , 'EARTH' , [ 2.0e-3_wp , 2 0.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vz' , 'km/s' , 'J2000' , 'EARTH' , [ 3.0e-3_wp , 3 0.0e-3_wp , 4 0.0e-3_wp ], error_cnt ) nullify ( traj ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'writing file ' // trim ( dir // filename2 ) // '...' open ( newunit = iunit , file = dir // filename2 , status = 'REPLACE' ) call json_print ( p , iunit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if close ( iunit ) !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_2 subroutine add_variables_to_input ( me , variable , units , frame , center , rdata , error_cnt ) !Used by test_2. implicit none type ( json_value ), pointer :: me character ( len =* ), intent ( in ) :: variable , units , frame , center real ( wp ), dimension (:), intent ( in ) :: rdata integer , intent ( inout ) :: error_cnt type ( json_value ), pointer :: var !a variable in the trajectory: !initialize: nullify ( var ) !create the object before data can be added: call json_create_object ( var , '' ) !name does not matter if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !variable info: call json_add ( var , 'VARIABLE' , trim ( variable )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'UNITS' , trim ( units )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'FRAME' , trim ( frame )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'CENTER' , trim ( center )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory [vector of reals]: call json_add ( var , 'DATA' , rdata ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add this variable to trajectory structure: call json_add ( me , var ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !cleanup: nullify ( var ) end subroutine add_variables_to_input end module jf_test_2_mod !***************************************************************************************** !***************************************************************************************** program jf_test_2 !! Second unit test. use jf_test_2_mod , only : test_2 implicit none integer :: n_errors n_errors = 0 call test_2 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_2 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_2.f90.html","title":"jf_test_2.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the third unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_3_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !working directory character ( len =* ), parameter :: filename2 = 'test2.json' contains subroutine test_3 ( error_cnt ) !! Read the file generated in [[test_2]], and extract some data from it. implicit none integer , intent ( out ) :: error_cnt integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval type ( json_file ) :: json !the JSON structure read from the file: integer :: i character ( kind = CK , len = 10 ) :: str real ( wp ), dimension (:), allocatable :: rvec error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 3' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // filename2 call json % load_file ( filename = dir // filename2 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' !get scalars: write ( error_unit , '(A)' ) '' call json % get ( 'inputs.integer_scalar' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,I5)' ) 'inputs.integer_scalar = ' , ival end if !get one element from a vector: write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(1).DATA(2)' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,F30.16)' ) 'trajectory(1).DATA(2) = ' , rval end if !get vectors: do i = 1 , 4 write ( str , fmt = '(I10)' ) i str = adjustl ( str ) write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(' // trim ( str ) // ').VARIABLE' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'trajectory(' // trim ( str ) // ').VARIABLE = ' // trim ( cval ) !...get the vector using the callback method: call json % get ( 'trajectory(' // trim ( str ) // ').DATA' , rvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,*(F30.16,1X))' ) 'trajectory(' // trim ( str ) // ').DATA = ' , rvec end if end if end do end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_3 end module jf_test_3_mod !***************************************************************************************** !***************************************************************************************** program jf_test_3 !! Third unit test. use jf_test_3_mod , only : test_3 implicit none integer :: n_errors n_errors = 0 call test_3 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_3 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_3.f90.html","title":"jf_test_3.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the forth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_4_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! working directory character ( len =* ), parameter :: filename4 = 'test4.json' contains subroutine test_4 ( error_cnt ) !! Populate a JSON structure, write it to a file, !! then read it. !! !! Also tests the json_value_to_string routine to write !! the file to a character string. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp type ( json_file ) :: json integer :: i character ( kind = CK , len = 10 ) :: istr character ( kind = CK , len = :), allocatable :: string error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 4' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'creating structure' call json_create_object ( p , dir // filename4 ) !create the value and associate the pointer !add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !config structure: call json_create_object ( inp , 'INPUTS' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add just integers: do i = 1 , 100 write ( istr , fmt = '(I10)' ) i istr = adjustl ( istr ) call json_add ( inp , 'x' // trim ( istr ), i ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to file' !write the file: call json_print ( p , trim ( dir // filename4 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to string' write ( error_unit , '(A)' ) '' !write it to a string, and print to console: call json_print_to_string ( p , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) string deallocate ( string ) !cleanup !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'read file' call json % load_file ( filename = dir // filename4 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'cleanup' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_4 end module jf_test_4_mod !***************************************************************************************** !***************************************************************************************** program jf_test_4 !! Fourth unit test. use jf_test_4_mod , only : test_4 implicit none integer :: n_errors n_errors = 0 call test_4 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_4 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_4.f90.html","title":"jf_test_4.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the fifth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_5_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename5 = 'test5.json' contains subroutine test_5 ( error_cnt ) !! Github issue example: https://github.com/josephalevin/fson/issues/12 !! !! Read an existing file and extract some variables. implicit none integer , intent ( out ) :: error_cnt integer :: vv integer , dimension (:), allocatable :: vvv real ( wp ) :: d type ( json_file ) :: json logical :: found error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 5' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) 'load file...' call json % load_file ( filename = dir // filename5 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console: write ( error_unit , '(A)' ) 'print file...' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'extract data...' write ( error_unit , '(A)' ) '--------------------------' call json % get ( 'Correl.ID2' , vv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,I5)' ) 'vv = ' , vv call json % get ( 'Correl.ID1' , vvv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,*(I5,1X))' ) 'vvv= ' , vvv call json % get ( 'Prior[3].mode' , d , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,E30.16)' ) 'd  = ' , d write ( error_unit , '(A)' ) '' end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_5 end module jf_test_5_mod !***************************************************************************************** !***************************************************************************************** program jf_test_5 !! Fifth unit test. use jf_test_5_mod , only : test_5 implicit none integer :: n_errors n_errors = 0 call test_5 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_5 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_5.f90.html","title":"jf_test_5.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the sixth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_6_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory contains subroutine test_6 ( error_cnt ) !! This example tries to read an invalid JSON file. implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json integer :: i character ( len =* ), dimension ( 2 ), parameter :: files = [ 'invalid.json ' ,& 'invalid2.json' ] error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 6 : invalid JSON files' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' do i = 1 , 2 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'load file: ' // trim ( files ( i )) write ( error_unit , '(A)' ) '' call json % load_file ( filename = dir // trim ( files ( i ))) if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'An error should have been raised!' error_cnt = error_cnt + 1 end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do end subroutine test_6 end module jf_test_6_mod !***************************************************************************************** !***************************************************************************************** program jf_test_6 !! Sixth unit test. use jf_test_6_mod , only : test_6 implicit none integer :: n_errors n_errors = 0 call test_6 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_6 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_6.f90.html","title":"jf_test_6.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the seventh unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_7_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none contains subroutine test_7 ( error_cnt ) !! Indent test implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: root , a , b , c , d , e , e1 , e2 , escaped_string , p logical :: found character ( kind = CK , len = 1 ), dimension (:), allocatable :: strvec character ( kind = CK , len = :), allocatable :: string found = . false . error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 7 : indent test' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !----------------------- ! jsonlint indention is !----------------------- !{ !    \"a\": { !        \"ints\": [ !            1, !            2, !            3 !        ], !        \"chars\": [ !            \"a\", !            \"b\", !            \"c\" !        ] !    }, !    \"b\": { !        \"c\": { !            \"val1\": 1066 !        } !    }, !    \"d\": { !        \"val2\": 1815 !    }, !    \"array\": [ !        { !            \"int1\": 1 !        }, !        { !            \"int1\": 1, !            \"int2\": 2 !        } !    ] !    \"escaped string\": \"\\\\\\/\\b\\f\\n\\r\\t\" !} !create a json structure: call json_create_object ( root , 'root' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( a , 'a' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'ints' , [ 1 , 2 , 3 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( b , 'b' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'chars' , [ 'a' , 'b' , 'c' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get_child ( a , 'chars' , p ) call json_get ( p , strvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( c , 'c' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( c , 'val1' , 1066 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( d , 'd' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( d , 'val2' , 1815 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_array ( e , 'array' ) !objects in an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e1 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e1 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e2 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int2' , 2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , a ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , b ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( b , c ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , d ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , e ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'escaped string' ,& '\\/' // & achar ( 8 ) // & achar ( 12 ) // & achar ( 10 ) // & achar ( 13 ) // & achar ( 9 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'wacky string' ,[ 'trim   ' , '  and  ' , ' adjust' , '   left' ],& trim_str = . true ., adjustl_str = . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( a ) !don't need these anymore nullify ( b ) nullify ( c ) nullify ( d ) nullify ( e ) nullify ( e1 ) nullify ( e2 ) nullify ( escaped_string ) call json_print ( root , output_unit ) !print to the console if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! look for the 'escaped string' entry call json_get ( root , 'escaped string' , escaped_string , found ) if ( json_failed () . or . . not . found ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get ( escaped_string , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) \"Fetched unescaped 'escaped string': \" // string ! remove the escaped string entry if ( found ) call json_remove ( escaped_string , destroy = . true .) call json_print ( root , error_unit ) !print to stderr if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( root ) !cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_7 end module jf_test_7_mod !***************************************************************************************** !***************************************************************************************** program jf_test_7 !! Seventh unit test. use jf_test_7_mod , only : test_7 implicit none integer :: n_errors n_errors = 0 call test_7 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_7 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_7.f90.html","title":"jf_test_7.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the eighth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_8_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none contains subroutine test_8 ( error_cnt ) !! read a JSON structure from a string implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p character ( len =* ), parameter :: newline = achar ( 10 ) character ( len =* ), parameter :: str = '{ \"label\": \"foo\",' // newline // ' \"value\": \"bar\" }' character ( len =* ), parameter :: str2 = '{ \"label\": \"foo\",' // newline // & '  \"value\": \"bar\",' // newline // & '  \"empty_array\": [],' // newline // & '  \"empty_object\": {}' // newline // & '}' character ( len =* ), parameter :: str_invalid = '{ \"label\": \"foo\",' // newline // ' \"value : \"bar\" }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 8 : read JSON from string' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 1:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '{ \"part a\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 2:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str2 , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part b\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Invalid test:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str_invalid , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'This should have failed!' error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part c\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_8 end module jf_test_8_mod !***************************************************************************************** !***************************************************************************************** program jf_test_8 !! Eighth unit test. use jf_test_8_mod , only : test_8 implicit none integer :: n_errors n_errors = 0 call test_8 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_8 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_8.f90.html","title":"jf_test_8.f90 – JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 3/2/2015 ! ! Module for the ninth unit test. module jf_test_9_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none !small file - 0.0 sec : http://www.json-generator.com !character(len=*),parameter :: filename = 'random1.json' !7 MB - 5.4 sec : http://www.json-generator.com character ( len =* ), parameter :: filename = 'big.json' !13 MB - 7.6 sec : http://mtgjson.com !character(len=*),parameter :: filename = 'AllSets.json' !....WARNING: this file is causing some error.... (bug in code?) !100 MB - takes forever... : https://github.com/seductiveapps/largeJSON !character(len=*),parameter :: filename = '100mb.json' !small file that contains unicode characters: !character(len=*),parameter :: filename = 'hello-world-ucs4.json'  !!!! test !!!! character ( len =* ), parameter :: dir = '../files/inputs/' !working directory contains subroutine test_9 ( error_cnt ) !! Open a random JSON file generated by http://www.json-generator.com implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: f real :: tstart , tend character ( len = :), allocatable :: str error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9a ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_file' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call f % load_file ( dir // filename ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !cleanup: call f % destroy () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9b ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_from_string' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call read_file ( dir // filename , str ) if ( allocated ( str )) then call f % load_from_string ( str ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time to parse: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !write(error_unit,'(A)') str   !!!! test !!!! !write(error_unit,'(A)') ''    !!!! test !!!! else write ( error_unit , '(A)' ) 'Error loading file' end if !cleanup: call f % destroy () end subroutine test_9 subroutine read_file ( filename , str ) !! Reads the contents of the file into the allocatable string str. !! If there are any problems, str will be returned unallocated. !! !!@warning Will this routine work if the file contains unicode characters?? implicit none character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable , intent ( out ) :: str integer :: iunit , istat , filesize open ( newunit = iunit ,& file = filename ,& status = 'OLD' ,& form = 'UNFORMATTED' ,& access = 'STREAM' ,& iostat = istat ) if ( istat == 0 ) then inquire ( file = filename , size = filesize ) if ( filesize > 0 ) then allocate ( character ( len = filesize ) :: str ) read ( iunit , pos = 1 , iostat = istat ) str if ( istat /= 0 ) deallocate ( str ) close ( iunit , iostat = istat ) end if end if end subroutine read_file end module jf_test_9_mod !***************************************************************************************** !***************************************************************************************** program jf_test_9 !! Ninth unit test. use jf_test_9_mod , only : test_9 implicit none integer :: n_errors n_errors = 0 call test_9 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_9 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_9.f90.html","title":"jf_test_9.f90 – JSON-Fortran"},{"text":"Source Code program example1 use json_module type ( json_file ) :: json logical :: found integer :: i , j , k ! initialize the module call json_initialize () ! read the file call json % load_file ( filename = '../files/inputs/test1.json' ) ! print the file to the console call json % print_file () ! extract data from the file ! [found can be used to check if the data was really there] call json % get ( 'version.major' , i , found ) if ( . not . found ) stop 1 call json % get ( 'version.minor' , j , found ) if ( . not . found ) stop 1 call json % get ( 'data(1).number' , k , found ) if ( . not . found ) stop 1 ! clean up call json % destroy () if ( json_failed ()) stop 1 end program example1","tags":"","loc":"sourcefile/jf_test_example1.f90.html","title":"jf_test_example1.f90 – JSON-Fortran"},{"text":"Source Code program example2 use , intrinsic :: iso_fortran_env , only : wp => real64 use json_module type ( json_value ), pointer :: p , inp ! initialize the module call json_initialize () ! initialize the structure: call json_create_object ( p , '' ) ! add an \"inputs\" object to the structure: call json_create_object ( inp , 'inputs' ) call json_add ( p , inp ) !add it to the root ! add some data to inputs: call json_add ( inp , 't0' , 0.1_wp ) call json_add ( inp , 'tf' , 1.1_wp ) call json_add ( inp , 'x0' , 999 9.0000 d0 ) call json_add ( inp , 'integer_scalar' , 787 ) call json_add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) call json_add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) call json_add ( inp , 'logical_scalar' , . true .) call json_add ( inp , 'logical_vector' , [. true ., . false ., . true .]) nullify ( inp ) !don't need this anymore ! write the file: call json_print ( p , '../files/example2.json' ) !cleanup: call json_destroy ( p ) if ( json_failed ()) stop 1 end program example2","tags":"","loc":"sourcefile/jf_test_example2.f90.html","title":"jf_test_example2.f90 – JSON-Fortran"},{"text":"Source Code !******************************************************************************************************* !> author: Izaak Beekman ! ! This program is run when configuring the json-fortran build, ! to determine whether or not ISO 10646/UCS4 characters are ! supported by the compiler. program test_iso_10646_support use iso_fortran_env , only : output_unit , error_unit implicit none integer , parameter :: UCS4_K = selected_char_kind ( 'ISO_10646' ) if ( UCS4_K == - 1 ) then !Not supported! write ( error_unit , '(A)' ) 'Your compiler does not support ISO 10646/UCS4 characters!' write ( error_unit , '(A)' ) 'JSON-Fortran must/will be configured to use the \"DEFAULT\"' write ( error_unit , '(A)' ) 'character set. (Should be \"ASCII\" on a reasonable system.)' stop 2 else write ( error_unit , '(A)' ) 'Congratulations! Your compiler supports ISO 10646/UCS4!' write ( error_unit , '(A)' ) 'JSON-Fortran may be configured to enable UCS4 support.' write ( output_unit , '(A)' ) 'UCS4_SUPPORTED' end if end program test_iso_10646_support !*******************************************************************************************************","tags":"","loc":"sourcefile/test_iso_10646_support.f90.html","title":"test_iso_10646_support.f90 – JSON-Fortran"},{"text":"public subroutine test_1(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read a sample JSON file and retrieve some data from it Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_file), public :: json integer, public :: ival character(kind=CK,len=:), public, allocatable :: cval real(kind=wp), public :: rval logical, public :: found type(json_value), public, pointer :: p Source Code subroutine test_1 ( error_cnt ) !! Read a sample JSON file and retrieve some data from it implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval logical :: found type ( json_value ), pointer :: p error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 1' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file ' // dir // filename1 call json % load_file ( filename = dir // filename1 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the file...' write ( output_unit , '(A)' ) '{ \"part a\" :' !Wrap 3 outputs to make stdout valid json call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'get some data from the file...' write ( error_unit , '(A)' ) '' call json % get ( 'version.svn' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,I5)' ) 'version.svn = ' , ival end if write ( error_unit , '(A)' ) '' call json % get ( 'data(1).array(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'data(1).array(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(1)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(1) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(3)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(3) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'data(2).real' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,E30.16)' ) 'data(2).real = ' , rval end if write ( error_unit , '(A)' ) '' call json % get ( 'files[4]' , cval ) !has hex characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[4] = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files[5]' , cval ) !string with spaces and no escape characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[5] = ' // trim ( cval ) end if ! ! Test of values that aren't there: ! Note: when using the \"found\" output, the exceptions are cleared automatically. ! write ( error_unit , '(A)' ) '' call json % get ( 'files[10]' , cval , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'files[10] not in file.' else write ( error_unit , '(1x,A)' ) 'files[10] = ' // trim ( cval ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' call json % get ( 'version.blah' , ival , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'version.blah not in file.' else write ( error_unit , '(A)' ) 'version.blah = ' , ival error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test removing data from the json structure:' call json % get ( 'files' , p ) !in the middle of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(1).array' , p ) !at the end of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(2).number' , p ) !at the beginning of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part b\" : ' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test replacing data from the json structure:' call json % get ( 'data(1)' , p ) call json_update ( p , 'name' , 'Cuthbert' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !call json%get('data(2)', p) !call json_update(p,'real',[1.0_wp, 2.0_wp, 3.0_wp],found)   !don't have one like this yet... !use the json_file procedure to update a variable: call json % update ( 'version.svn' , 999 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part c\" : ' call json % print_file () write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_1","tags":"","loc":"proc/test_1.html","title":"test_1 – JSON-Fortran"},{"text":"public subroutine test_10(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Test some of the lesser-used features of the library Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=256), public, dimension(:), allocatable :: str_vec type(json_file), public :: f type(json_file), public :: f2 type(json_value), public, pointer :: p character(kind=CK,len=:), public, allocatable :: str character(kind=CK,len=:), public, allocatable :: name logical, public :: found logical, public :: lval integer, public :: var_type integer, public :: n_children character(kind=CDK,len=*), public, parameter :: json_str = '{ \"blah\": 123 }' Source Code subroutine test_10 ( error_cnt ) !! Test some of the lesser-used features of the library implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = 256 ), dimension (:), allocatable :: str_vec type ( json_file ) :: f , f2 type ( json_value ), pointer :: p character ( kind = CK , len = :), allocatable :: str , name logical :: found , lval integer :: var_type , n_children character ( kind = CDK , len =* ), parameter :: json_str = '{ \"blah\": 123 }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 10 ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) // '...' call f % load_file ( dir // filename ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_move_pointer...' call f2 % move ( f ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_load_from_string...' call f % load_from_string ( json_str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_print_to_string...' call f % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_variable_info...' call f % info ( 'blah' , found , var_type , n_children ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( var_type == json_integer . and . n_children == 0 ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error invalid values:' , var_type , n_children error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_get_logical...' call f2 % get ( 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . lval ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result.' error_cnt = error_cnt + 1 end if end if ! json_file_get_logical_vec .... [add this] write ( error_unit , '(A)' ) 'json_file_get_string_vec...' call f2 % get ( 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable present]...' call f2 % update ( 'data(1).tf1' ,. false ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable not present]...' call f2 % update ( 'new_logical' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_real [variable present]...' call f2 % update ( 'data[2].real' , 10 0.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_real [variable not present]...' call f2 % update ( 'new_real' , 177 6.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_string [variable present]...' call f2 % update ( 'version.string' , '10.0.0' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_string [variable not present]...' call f2 % update ( 'new_string' , 'foo' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_get_integer...' call f2 % get ( '$' , p , found ) !get root if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' write ( error_unit , '(A)' ) 'json_info...' call json_info ( p , var_type , n_children , name ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_remove_if_present...' call json_remove_if_present ( p , 'version.patch' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_logical...' call json_update ( p , 'data(1).tf1' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_double...' call json_update ( p , 'data(2).real' , - 1.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_logical...' call json_get ( p , 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_string_vec...' call json_get ( p , 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_create...' write ( error_unit , '(A)' ) 'json_create_logical...' ; call json_destroy ( p ); call json_create_logical ( p ,. true ., 'foo' ) write ( error_unit , '(A)' ) 'json_create_integer...' ; call json_destroy ( p ); call json_create_integer ( p , 1000 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_double ...' ; call json_destroy ( p ); call json_create_double ( p , 9.0 d0 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_string ...' ; call json_destroy ( p ); call json_create_string ( p , 'foo' , 'bar' ) write ( error_unit , '(A)' ) 'json_create_null   ...' ; call json_destroy ( p ); call json_create_null ( p , 'foo' ) write ( error_unit , '(A)' ) 'json_create_object ...' ; call json_destroy ( p ); call json_create_object ( p , 'foo' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- !cleanup: !call f%destroy()   !WARNING: causing \"pointer being freed was not allocated\" errors.... need to investigate !call f2%destroy() end subroutine test_10","tags":"","loc":"proc/test_10.html","title":"test_10 – JSON-Fortran"},{"text":"public subroutine test_11(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file and extract some data from it. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: cval type(json_file), public :: json type(json_file), public :: clone Source Code subroutine test_11 ( error_cnt ) !! Read the file and extract some data from it. implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = :), allocatable :: cval type ( json_file ) :: json !the JSON structure read from the file: # ifdef USE_UCS4 type ( json_file ) :: clone # endif error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 11' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' # ifdef USE_UCS4 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // unicode_file call json % load_file ( filename = dir // unicode_file ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' call clone % load_from_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call clone % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // unicode_file // '\"' call clone % print_file ( '../files/' // unicode_file ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call clone % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if # endif ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // ascii_equivalent write ( error_unit , '(A)' ) 'This is the ascii equivalent of \"../files/inputs/hello-world-ucs4.json\"' call json % load_file ( filename = dir // ascii_equivalent ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call json % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // ascii_equivalent // '\"' call json % print_file ( '../files/' // ascii_equivalent ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_11","tags":"","loc":"proc/test_11.html","title":"test_11 – JSON-Fortran"},{"text":"public subroutine test_12(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: imx = 5 integer, public, parameter :: jmx = 3 integer, public, parameter :: kmx = 4 dimensions for raw work array of primitive type integer, public, dimension(3) :: shape shape of work array integer, public, dimension(:), allocatable :: fetched_shape retrieved shape type(json_value), public, pointer :: root type(json_value), public, pointer :: meta_array json nodes to work with type(json_value), public, pointer :: tmp_json_ptr type(json_file), public :: my_file real(kind=wp), public, dimension(imx,jmx,kmx) :: raw_array raw work array real(kind=wp), public :: array_element real(kind=wp), public, dimension(:), allocatable :: fetched_array character(kind=CK,len=:), public, allocatable :: description integer, public :: i integer, public :: j integer, public :: k loop indices integer, public :: array_length integer, public :: lun logical, public :: existed logical, public, dimension(:), allocatable :: SOS Subroutines subroutine check_errors(assertion) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: assertion subroutine get_3D_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type(json_value), intent(in), pointer :: element integer, intent(in) :: i index integer, intent(in) :: count size of array Source Code subroutine test_12 ( error_cnt ) implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller integer , parameter :: imx = 5 , jmx = 3 , kmx = 4 !! dimensions for raw work array of primitive type integer , dimension ( 3 ) :: shape !! shape of work array integer , dimension (:), allocatable :: fetched_shape !! retrieved shape type ( json_value ), pointer :: root , meta_array !! json nodes to work with type ( json_value ), pointer :: tmp_json_ptr type ( json_file ) :: my_file real ( wp ), dimension ( imx , jmx , kmx ) :: raw_array !! raw work array real ( wp ) :: array_element real ( wp ), dimension (:), allocatable :: fetched_array character ( kind = CK , len = :), allocatable :: description integer :: i , j , k !! loop indices integer :: array_length , lun logical :: existed logical , dimension (:), allocatable :: SOS error_cnt = 0 call json_initialize ( verbose = . true ., real_format = 'G' ) call check_errors () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 12' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! populate the raw array forall ( i = 1 : imx , j = 1 : jmx , k = 1 : kmx ) ! could use size(... , dim=...) instead of constants raw_array ( i , j , k ) = i + ( j - 1 ) * imx + ( k - 1 ) * imx * jmx end forall call json_create_object ( root , dir // file ) call check_errors () call json_create_object ( meta_array , 'array data' ) call check_errors () shape = [ size ( raw_array , dim = 1 ), size ( raw_array , dim = 2 ), size ( raw_array , dim = 3 )] call json_add ( meta_array , 'shape' , shape ) call check_errors () call json_add ( meta_array , 'total size' , size ( raw_array )) call check_errors () call json_update ( meta_array , 'total size' , size ( raw_array ), found = existed ) call check_errors ( existed ) call json_add ( meta_array , CK_ 'description' , 'test data' ) call check_errors () ! now add the array ! N.B. `json_add()` only accepts 1-D arrays and scalars, so transform with `reshape` ! N.B. reshape populates new array in \"array element order\". ! C.F. \"Modern Fortran Explained\", by Metcalf, Cohen and Reid, p. 24. ! N.B. Fortran is a column major language call json_add ( meta_array , 'data' , reshape ( raw_array , [ size ( raw_array ) ] ) ) call check_errors () ! now put it all together call json_add ( root , meta_array ) call check_errors () write ( error_unit , '(A)' ) \"Print the JSON object to stderr:\" call json_print ( root , error_unit ) call check_errors () call json_get ( root , '$.array data.data(1)' , array_element ) call check_errors ( abs ( array_element - 1.0_wp ) <= TOL ) call json_get ( root , '@.array data.shape' , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_update ( meta_array , 'description' , CK_ 'Test Data' , found = existed ) call check_errors ( existed ) call json_update ( meta_array , CK_ 'description' , 'Test data' , found = existed ) call check_errors ( existed ) call json_get ( meta_array , 'description' , description ) call check_errors ( 'Test data' == description ) call json_get ( root , 'array data.total size' , array_length ) call check_errors ( array_length == imx * jmx * kmx ) sos = [. true ., . true ., . true ., & . false ., . false ., . false ., & . true ., . true ., . true .] call json_add ( root , 'SOS' , sos ) call check_errors () call json_get ( root , 'SOS' , sos ) call check_errors () call json_add ( root , 'vector string' , [ CK_ 'only one value' ]) call check_errors () call json_add ( root , CK_ 'page' , [ 'The quick brown fox     ' , 'jumps over the lazy dog.' ]) call check_errors () call json_get ( root , 'SOS' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , sos ) call check_errors () call json_get ( meta_array , 'shape' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_get ( meta_array , 'data' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call json_get ( root , 'array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) raw_array = 0 call json_get ( me = root , path = 'array data.data' , array_callback = get_3D_from_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) my_file = json_file ( root ) call my_file % update ( 'array data.description' , CK_ 'vector data' , found = existed ) call check_errors ( existed ) call my_file % update ( CK_ 'array data.description' , 'Vector data' , found = existed ) call check_errors ( existed ) call my_file % get ( 'SOS' , sos ) call check_errors () call my_file % get ( '$array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call my_file % get ( tmp_json_ptr ) call check_errors ( associated ( tmp_json_ptr , root )) open ( file = dir // file , newunit = lun , form = 'formatted' , action = 'write' ) call my_file % print_file ( lun ) call check_errors () close ( lun ) contains subroutine check_errors ( assertion ) logical , optional , intent ( in ) :: assertion if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( present ( assertion )) then if (. not . assertion ) error_cnt = error_cnt + 1 end if end subroutine check_errors subroutine get_3D_from_array ( element , i , count ) type ( json_value ), pointer , intent ( in ) :: element integer , intent ( in ) :: i !!index integer , intent ( in ) :: count !!size of array integer :: useless !! assign count to this to silence warnings ! let's pretend we're c programmers! call json_get ( element , raw_array ( & mod ( i - 1 , imx ) + 1 , & ! i index mod (( i - 1 ) / imx , jmx ) + 1 , & ! j index mod (( i - 1 ) / imx / jmx , kmx ) + 1 ) ) ! k inded useless = count end subroutine get_3D_from_array end subroutine test_12","tags":"","loc":"proc/test_12.html","title":"test_12 – JSON-Fortran"},{"text":"public subroutine test_13(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests different real format strings using repeated calls to [[json_initialize]]. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_file), public :: my_file character(kind=CK,len=:), public, allocatable :: str integer, public :: i character(len=2), public, parameter, dimension(4) :: fmts = ['g ', 'e ', 'en', 'es'] format statements to test Source Code subroutine test_13 ( error_cnt ) !! Tests different real format strings using repeated calls to [[json_initialize]]. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_file ) :: my_file character ( kind = CK , len = :), allocatable :: str integer :: i character ( len = 2 ), dimension ( 4 ), parameter :: fmts = [ 'g ' , 'e ' , 'en' , 'es' ] !! format statements to test write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 13' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 do i = 1 , size ( fmts ) call json_initialize ( real_format = trim ( fmts ( i ))) call my_file % load_from_string ( '{ \"value\": 1234.56789 }' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call my_file % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( output_unit , '(A)' ) str end if call my_file % destroy () end do end subroutine test_13","tags":"","loc":"proc/test_13.html","title":"test_13 – JSON-Fortran"},{"text":"public subroutine test_14(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests the traversal of a JSON structure It traverses the structure, looks for all \"name\" variables, and changes the name. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_value), public, pointer :: json Source Code subroutine test_14 ( error_cnt ) !! Tests the traversal of a JSON structure !! !! It traverses the structure, looks for all \"name\" variables, and changes the name. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_value ), pointer :: json write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 14' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 icount = 0 !number of name changes (should be 2) call json_initialize () !initialize the module call json_parse ( dir // filename1 , json ) !read the file if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_traverse ( json , rename ) !traverse all nodes in the structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( icount /= 2 ) then write ( error_unit , '(A)' ) 'Error: should be 2 \"name\" variables in this file: ' // filename1 error_cnt = error_cnt + 1 end if if ( error_cnt == 0 ) then write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' All names changed to Fred:' write ( error_unit , '(A)' ) '' call json_print ( json , output_unit ) write ( error_unit , '(A)' ) '' end if call json_destroy ( json ) !clean up if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_14","tags":"","loc":"proc/test_14.html","title":"test_14 – JSON-Fortran"},{"text":"public subroutine rename(p, finished) Arguments Type Intent Optional Attributes Name type(json_value), intent(in), pointer :: p logical, intent(out) :: finished Description change all \"name\" variable values to \"Fred\" Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: var_type character(kind=CK,len=:), public, allocatable :: str logical, public :: found Source Code subroutine rename ( p , finished ) !! change all \"name\" variable values to \"Fred\" implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( out ) :: finished integer :: var_type character ( kind = CK , len = :), allocatable :: str logical :: found !get info about this variable: call json_info ( p , var_type = var_type , name = str ) !it must be a string named \"name\": if ( var_type == json_string . and . str == 'name' ) then call json_get ( p , '@' , str ) ! get original name call json_update ( p , '@' , 'Fred' , found ) !change it write ( error_unit , '(A)' ) str // ' name changed' icount = icount + 1 end if !cleanup: if ( allocated ( str )) deallocate ( str ) !always false, since we want to traverse all nodes: finished = . false . end subroutine rename","tags":"","loc":"proc/rename.html","title":"rename – JSON-Fortran"},{"text":"public subroutine test_2(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure and write it to a file. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_value), public, pointer :: p type(json_value), public, pointer :: inp type(json_value), public, pointer :: traj integer, public :: iunit Source Code subroutine test_2 ( error_cnt ) !! Populate a JSON structure and write it to a file. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp , traj integer :: iunit error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 2' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !root: call json_create_object ( p , dir // filename2 ) ! create the value and associate the pointer ! add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'initialize the structure...' !config structure: call json_create_object ( inp , 'inputs' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory structure: call json_create_array ( traj , 'trajectory' ) !an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , traj ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'adding some data to structure...' !add some variables: !input variables: call json_add ( inp , 't0' , 0.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'tf' , 1.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'x0' , 999 9.000_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_scalar' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_scalar' , . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_vector' , [. true ., . false ., . true .]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) !trajectory variables: call add_variables_to_input ( traj , 'Rx' , 'km' , 'J2000' , 'EARTH' , [ 1.0_wp , 2.0_wp , 3.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Ry' , 'km' , 'J2000' , 'EARTH' , [ 1 0.0_wp , 2 0.0_wp , 3 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Rz' , 'km' , 'J2000' , 'EARTH' , [ 10 0.0_wp , 20 0.0 d0 , 30 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vx' , 'km/s' , 'J2000' , 'EARTH' , [ 1.0e-3_wp , 2.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vy' , 'km/s' , 'J2000' , 'EARTH' , [ 2.0e-3_wp , 2 0.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vz' , 'km/s' , 'J2000' , 'EARTH' , [ 3.0e-3_wp , 3 0.0e-3_wp , 4 0.0e-3_wp ], error_cnt ) nullify ( traj ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'writing file ' // trim ( dir // filename2 ) // '...' open ( newunit = iunit , file = dir // filename2 , status = 'REPLACE' ) call json_print ( p , iunit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if close ( iunit ) !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_2","tags":"","loc":"proc/test_2.html","title":"test_2 – JSON-Fortran"},{"text":"public subroutine add_variables_to_input(me, variable, units, frame, center, rdata, error_cnt) Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: me character(len=*), intent(in) :: variable character(len=*), intent(in) :: units character(len=*), intent(in) :: frame character(len=*), intent(in) :: center real(kind=wp), intent(in), dimension(:) :: rdata integer, intent(inout) :: error_cnt Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_value), public, pointer :: var Source Code subroutine add_variables_to_input ( me , variable , units , frame , center , rdata , error_cnt ) !Used by test_2. implicit none type ( json_value ), pointer :: me character ( len =* ), intent ( in ) :: variable , units , frame , center real ( wp ), dimension (:), intent ( in ) :: rdata integer , intent ( inout ) :: error_cnt type ( json_value ), pointer :: var !a variable in the trajectory: !initialize: nullify ( var ) !create the object before data can be added: call json_create_object ( var , '' ) !name does not matter if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !variable info: call json_add ( var , 'VARIABLE' , trim ( variable )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'UNITS' , trim ( units )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'FRAME' , trim ( frame )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'CENTER' , trim ( center )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory [vector of reals]: call json_add ( var , 'DATA' , rdata ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add this variable to trajectory structure: call json_add ( me , var ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !cleanup: nullify ( var ) end subroutine add_variables_to_input","tags":"","loc":"proc/add_variables_to_input.html","title":"add_variables_to_input – JSON-Fortran"},{"text":"public subroutine test_3(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file generated in test_2 , and extract some data from it. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: ival character(kind=CK,len=:), public, allocatable :: cval real(kind=wp), public :: rval type(json_file), public :: json integer, public :: i character(kind=CK,len=10), public :: str real(kind=wp), public, dimension(:), allocatable :: rvec Source Code subroutine test_3 ( error_cnt ) !! Read the file generated in [[test_2]], and extract some data from it. implicit none integer , intent ( out ) :: error_cnt integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval type ( json_file ) :: json !the JSON structure read from the file: integer :: i character ( kind = CK , len = 10 ) :: str real ( wp ), dimension (:), allocatable :: rvec error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 3' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // filename2 call json % load_file ( filename = dir // filename2 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' !get scalars: write ( error_unit , '(A)' ) '' call json % get ( 'inputs.integer_scalar' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,I5)' ) 'inputs.integer_scalar = ' , ival end if !get one element from a vector: write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(1).DATA(2)' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,F30.16)' ) 'trajectory(1).DATA(2) = ' , rval end if !get vectors: do i = 1 , 4 write ( str , fmt = '(I10)' ) i str = adjustl ( str ) write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(' // trim ( str ) // ').VARIABLE' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'trajectory(' // trim ( str ) // ').VARIABLE = ' // trim ( cval ) !...get the vector using the callback method: call json % get ( 'trajectory(' // trim ( str ) // ').DATA' , rvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,*(F30.16,1X))' ) 'trajectory(' // trim ( str ) // ').DATA = ' , rvec end if end if end do end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_3","tags":"","loc":"proc/test_3.html","title":"test_3 – JSON-Fortran"},{"text":"public subroutine test_4(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure, write it to a file,\n then read it. Also tests the json_value_to_string routine to write\n the file to a character string. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_value), public, pointer :: p type(json_value), public, pointer :: inp type(json_file), public :: json integer, public :: i character(kind=CK,len=10), public :: istr character(kind=CK,len=:), public, allocatable :: string Source Code subroutine test_4 ( error_cnt ) !! Populate a JSON structure, write it to a file, !! then read it. !! !! Also tests the json_value_to_string routine to write !! the file to a character string. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp type ( json_file ) :: json integer :: i character ( kind = CK , len = 10 ) :: istr character ( kind = CK , len = :), allocatable :: string error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 4' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'creating structure' call json_create_object ( p , dir // filename4 ) !create the value and associate the pointer !add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !config structure: call json_create_object ( inp , 'INPUTS' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add just integers: do i = 1 , 100 write ( istr , fmt = '(I10)' ) i istr = adjustl ( istr ) call json_add ( inp , 'x' // trim ( istr ), i ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to file' !write the file: call json_print ( p , trim ( dir // filename4 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to string' write ( error_unit , '(A)' ) '' !write it to a string, and print to console: call json_print_to_string ( p , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) string deallocate ( string ) !cleanup !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'read file' call json % load_file ( filename = dir // filename4 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'cleanup' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_4","tags":"","loc":"proc/test_4.html","title":"test_4 – JSON-Fortran"},{"text":"public subroutine test_5(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Github issue example: https://github.com/josephalevin/fson/issues/12 Read an existing file and extract some variables. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: vv integer, public, dimension(:), allocatable :: vvv real(kind=wp), public :: d type(json_file), public :: json logical, public :: found Source Code subroutine test_5 ( error_cnt ) !! Github issue example: https://github.com/josephalevin/fson/issues/12 !! !! Read an existing file and extract some variables. implicit none integer , intent ( out ) :: error_cnt integer :: vv integer , dimension (:), allocatable :: vvv real ( wp ) :: d type ( json_file ) :: json logical :: found error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 5' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) 'load file...' call json % load_file ( filename = dir // filename5 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console: write ( error_unit , '(A)' ) 'print file...' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'extract data...' write ( error_unit , '(A)' ) '--------------------------' call json % get ( 'Correl.ID2' , vv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,I5)' ) 'vv = ' , vv call json % get ( 'Correl.ID1' , vvv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,*(I5,1X))' ) 'vvv= ' , vvv call json % get ( 'Prior[3].mode' , d , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,E30.16)' ) 'd  = ' , d write ( error_unit , '(A)' ) '' end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_5","tags":"","loc":"proc/test_5.html","title":"test_5 – JSON-Fortran"},{"text":"public subroutine test_6(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description This example tries to read an invalid JSON file. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_file), public :: json integer, public :: i character(len=*), public, parameter, dimension(2) :: files = ['invalid.json ', 'invalid2.json'] Source Code subroutine test_6 ( error_cnt ) !! This example tries to read an invalid JSON file. implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json integer :: i character ( len =* ), dimension ( 2 ), parameter :: files = [ 'invalid.json ' ,& 'invalid2.json' ] error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 6 : invalid JSON files' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' do i = 1 , 2 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'load file: ' // trim ( files ( i )) write ( error_unit , '(A)' ) '' call json % load_file ( filename = dir // trim ( files ( i ))) if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'An error should have been raised!' error_cnt = error_cnt + 1 end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do end subroutine test_6","tags":"","loc":"proc/test_6.html","title":"test_6 – JSON-Fortran"},{"text":"public subroutine test_7(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Indent test Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_value), public, pointer :: root type(json_value), public, pointer :: a type(json_value), public, pointer :: b type(json_value), public, pointer :: c type(json_value), public, pointer :: d type(json_value), public, pointer :: e type(json_value), public, pointer :: e1 type(json_value), public, pointer :: e2 type(json_value), public, pointer :: escaped_string type(json_value), public, pointer :: p logical, public :: found character(kind=CK,len=1), public, dimension(:), allocatable :: strvec character(kind=CK,len=:), public, allocatable :: string Source Code subroutine test_7 ( error_cnt ) !! Indent test implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: root , a , b , c , d , e , e1 , e2 , escaped_string , p logical :: found character ( kind = CK , len = 1 ), dimension (:), allocatable :: strvec character ( kind = CK , len = :), allocatable :: string found = . false . error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 7 : indent test' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !----------------------- ! jsonlint indention is !----------------------- !{ !    \"a\": { !        \"ints\": [ !            1, !            2, !            3 !        ], !        \"chars\": [ !            \"a\", !            \"b\", !            \"c\" !        ] !    }, !    \"b\": { !        \"c\": { !            \"val1\": 1066 !        } !    }, !    \"d\": { !        \"val2\": 1815 !    }, !    \"array\": [ !        { !            \"int1\": 1 !        }, !        { !            \"int1\": 1, !            \"int2\": 2 !        } !    ] !    \"escaped string\": \"\\\\\\/\\b\\f\\n\\r\\t\" !} !create a json structure: call json_create_object ( root , 'root' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( a , 'a' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'ints' , [ 1 , 2 , 3 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( b , 'b' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'chars' , [ 'a' , 'b' , 'c' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get_child ( a , 'chars' , p ) call json_get ( p , strvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( c , 'c' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( c , 'val1' , 1066 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( d , 'd' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( d , 'val2' , 1815 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_array ( e , 'array' ) !objects in an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e1 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e1 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e2 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int2' , 2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , a ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , b ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( b , c ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , d ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , e ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'escaped string' ,& '\\/' // & achar ( 8 ) // & achar ( 12 ) // & achar ( 10 ) // & achar ( 13 ) // & achar ( 9 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'wacky string' ,[ 'trim   ' , '  and  ' , ' adjust' , '   left' ],& trim_str = . true ., adjustl_str = . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( a ) !don't need these anymore nullify ( b ) nullify ( c ) nullify ( d ) nullify ( e ) nullify ( e1 ) nullify ( e2 ) nullify ( escaped_string ) call json_print ( root , output_unit ) !print to the console if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! look for the 'escaped string' entry call json_get ( root , 'escaped string' , escaped_string , found ) if ( json_failed () . or . . not . found ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get ( escaped_string , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) \"Fetched unescaped 'escaped string': \" // string ! remove the escaped string entry if ( found ) call json_remove ( escaped_string , destroy = . true .) call json_print ( root , error_unit ) !print to stderr if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( root ) !cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_7","tags":"","loc":"proc/test_7.html","title":"test_7 – JSON-Fortran"},{"text":"public subroutine test_8(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description read a JSON structure from a string Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_value), public, pointer :: p character(len=*), public, parameter :: newline = achar(10) character(len=*), public, parameter :: str = '{ \"label\": \"foo\",'//newline//' \"value\": \"bar\" }' character(len=*), public, parameter :: str2 = '{ \"label\": \"foo\",'//newline//'  \"value\": \"bar\",'//newline//'  \"empty_array\": [],'//newline//'  \"empty_object\": {}'//newline//'}' character(len=*), public, parameter :: str_invalid = '{ \"label\": \"foo\",'//newline//' \"value : \"bar\" }' Source Code subroutine test_8 ( error_cnt ) !! read a JSON structure from a string implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p character ( len =* ), parameter :: newline = achar ( 10 ) character ( len =* ), parameter :: str = '{ \"label\": \"foo\",' // newline // ' \"value\": \"bar\" }' character ( len =* ), parameter :: str2 = '{ \"label\": \"foo\",' // newline // & '  \"value\": \"bar\",' // newline // & '  \"empty_array\": [],' // newline // & '  \"empty_object\": {}' // newline // & '}' character ( len =* ), parameter :: str_invalid = '{ \"label\": \"foo\",' // newline // ' \"value : \"bar\" }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 8 : read JSON from string' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 1:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '{ \"part a\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 2:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str2 , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part b\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Invalid test:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str_invalid , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'This should have failed!' error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part c\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_8","tags":"","loc":"proc/test_8.html","title":"test_8 – JSON-Fortran"},{"text":"public subroutine test_9(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Open a random JSON file generated by http://www.json-generator.com Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(json_file), public :: f real, public :: tstart real, public :: tend character(len=:), public, allocatable :: str Source Code subroutine test_9 ( error_cnt ) !! Open a random JSON file generated by http://www.json-generator.com implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: f real :: tstart , tend character ( len = :), allocatable :: str error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9a ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_file' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call f % load_file ( dir // filename ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !cleanup: call f % destroy () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9b ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_from_string' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call read_file ( dir // filename , str ) if ( allocated ( str )) then call f % load_from_string ( str ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time to parse: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !write(error_unit,'(A)') str   !!!! test !!!! !write(error_unit,'(A)') ''    !!!! test !!!! else write ( error_unit , '(A)' ) 'Error loading file' end if !cleanup: call f % destroy () end subroutine test_9","tags":"","loc":"proc/test_9.html","title":"test_9 – JSON-Fortran"},{"text":"public subroutine read_file(filename, str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: str Description Reads the contents of the file into the allocatable string str.\n If there are any problems, str will be returned unallocated. Warning Will this routine work if the file contains unicode characters?? Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: iunit integer, public :: istat integer, public :: filesize Source Code subroutine read_file ( filename , str ) !! Reads the contents of the file into the allocatable string str. !! If there are any problems, str will be returned unallocated. !! !!@warning Will this routine work if the file contains unicode characters?? implicit none character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable , intent ( out ) :: str integer :: iunit , istat , filesize open ( newunit = iunit ,& file = filename ,& status = 'OLD' ,& form = 'UNFORMATTED' ,& access = 'STREAM' ,& iostat = istat ) if ( istat == 0 ) then inquire ( file = filename , size = filesize ) if ( filesize > 0 ) then allocate ( character ( len = filesize ) :: str ) read ( iunit , pos = 1 , iostat = istat ) str if ( istat /= 0 ) deallocate ( str ) close ( iunit , iostat = istat ) end if end if end subroutine read_file","tags":"","loc":"proc/read_file.html","title":"read_file – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the first unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename1 = 'test1.json' Subroutines public subroutine test_1 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read a sample JSON file and retrieve some data from it","tags":"","loc":"module/jf_test_1_mod.html","title":"jf_test_1_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the tenth unit test. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: filename = 'test1.json' character(len=*), public, parameter :: dir = '../files/inputs/' Subroutines public subroutine test_10 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Test some of the lesser-used features of the library","tags":"","loc":"module/jf_test_10_mod.html","title":"jf_test_10_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the 11th unit test to test unicode support if enabled. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: unicode_file = 'hello-world-ucs4.json' character(len=*), public, parameter :: ascii_equivalent = 'hello-world-ascii.json' Subroutines public subroutine test_11 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file and extract some data from it.","tags":"","loc":"module/jf_test_11_mod.html","title":"jf_test_11_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the 12th unit test. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' Path to write JSON file to character(len=*), public, parameter :: file = 'test12.json' Filename to write real(kind=wp), public, parameter :: TOL = 100*epsilon(1.0_wp) Tolerance for real comparisons Subroutines public subroutine test_12 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller","tags":"","loc":"module/jf_test_12_mod.html","title":"jf_test_12_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the 13th unit test. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines public subroutine test_13 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests different real format strings using repeated calls to [[json_initialize]].","tags":"","loc":"module/jf_test_13_mod.html","title":"jf_test_13_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the 14th unit test. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename1 = 'test1.json' the file to read integer, public :: icount = 0 a count of the number of \"name\" variables found Subroutines public subroutine test_14 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests the traversal of a JSON structure public subroutine rename (p, finished) Arguments Type Intent Optional Attributes Name type(json_value), intent(in), pointer :: p logical, intent(out) :: finished Description change all \"name\" variable values to \"Fred\"","tags":"","loc":"module/jf_test_14_mod.html","title":"jf_test_14_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the second unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' working directory character(len=*), public, parameter :: filename2 = 'test2.json' Subroutines public subroutine test_2 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure and write it to a file. public subroutine add_variables_to_input (me, variable, units, frame, center, rdata, error_cnt) Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: me character(len=*), intent(in) :: variable character(len=*), intent(in) :: units character(len=*), intent(in) :: frame character(len=*), intent(in) :: center real(kind=wp), intent(in), dimension(:) :: rdata integer, intent(inout) :: error_cnt","tags":"","loc":"module/jf_test_2_mod.html","title":"jf_test_2_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the third unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' character(len=*), public, parameter :: filename2 = 'test2.json' Subroutines public subroutine test_3 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file generated in test_2 , and extract some data from it.","tags":"","loc":"module/jf_test_3_mod.html","title":"jf_test_3_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the forth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' working directory character(len=*), public, parameter :: filename4 = 'test4.json' Subroutines public subroutine test_4 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure, write it to a file,\n then read it.","tags":"","loc":"module/jf_test_4_mod.html","title":"jf_test_4_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the fifth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename5 = 'test5.json' Subroutines public subroutine test_5 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Github issue example: https://github.com/josephalevin/fson/issues/12","tags":"","loc":"module/jf_test_5_mod.html","title":"jf_test_5_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the sixth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory Subroutines public subroutine test_6 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description This example tries to read an invalid JSON file.","tags":"","loc":"module/jf_test_6_mod.html","title":"jf_test_6_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the seventh unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines public subroutine test_7 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Indent test","tags":"","loc":"module/jf_test_7_mod.html","title":"jf_test_7_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the eighth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines public subroutine test_8 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description read a JSON structure from a string","tags":"","loc":"module/jf_test_8_mod.html","title":"jf_test_8_mod – JSON-Fortran"},{"text":"Uses: json_module iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module for the ninth unit test. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: filename = 'big.json' character(len=*), public, parameter :: dir = '../files/inputs/' Subroutines public subroutine test_9 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Open a random JSON file generated by http://www.json-generator.com public subroutine read_file (filename, str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: str Description Reads the contents of the file into the allocatable string str.\n If there are any problems, str will be returned unallocated.","tags":"","loc":"module/jf_test_9_mod.html","title":"jf_test_9_mod – JSON-Fortran"},{"text":"Uses: jf_test_1_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. First unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_1 !! First unit test. use jf_test_1_mod , only : test_1 implicit none integer :: n_errors n_errors = 0 call test_1 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_1","tags":"","loc":"program/jf_test_1.html","title":"jf_test_1 – JSON-Fortran"},{"text":"Uses: jf_test_10_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Tenth unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_10 !! Tenth unit test. use jf_test_10_mod , only : test_10 implicit none integer :: n_errors n_errors = 0 call test_10 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_10","tags":"","loc":"program/jf_test_10.html","title":"jf_test_10 – JSON-Fortran"},{"text":"Uses: jf_test_11_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. 11th unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_11 !! 11th unit test. use jf_test_11_mod , only : test_11 implicit none integer :: n_errors n_errors = 0 call test_11 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_11","tags":"","loc":"program/jf_test_11.html","title":"jf_test_11 – JSON-Fortran"},{"text":"Uses: jf_test_12_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. 12th unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_12 !! 12th unit test. use jf_test_12_mod , only : test_12 implicit none integer :: n_errors n_errors = 0 call test_12 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_12","tags":"","loc":"program/jf_test_12.html","title":"jf_test_12 – JSON-Fortran"},{"text":"Uses: jf_test_13_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. 13th unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_13 !! 13th unit test. use jf_test_13_mod , only : test_13 implicit none integer :: n_errors call test_13 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_13","tags":"","loc":"program/jf_test_13.html","title":"jf_test_13 – JSON-Fortran"},{"text":"Uses: jf_test_14_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. 14th unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_14 !! 14th unit test. use jf_test_14_mod , only : test_14 implicit none integer :: n_errors call test_14 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_14","tags":"","loc":"program/jf_test_14.html","title":"jf_test_14 – JSON-Fortran"},{"text":"Uses: jf_test_2_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Second unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_2 !! Second unit test. use jf_test_2_mod , only : test_2 implicit none integer :: n_errors n_errors = 0 call test_2 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_2","tags":"","loc":"program/jf_test_2.html","title":"jf_test_2 – JSON-Fortran"},{"text":"Uses: jf_test_3_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Third unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_3 !! Third unit test. use jf_test_3_mod , only : test_3 implicit none integer :: n_errors n_errors = 0 call test_3 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_3","tags":"","loc":"program/jf_test_3.html","title":"jf_test_3 – JSON-Fortran"},{"text":"Uses: jf_test_4_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Fourth unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_4 !! Fourth unit test. use jf_test_4_mod , only : test_4 implicit none integer :: n_errors n_errors = 0 call test_4 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_4","tags":"","loc":"program/jf_test_4.html","title":"jf_test_4 – JSON-Fortran"},{"text":"Uses: jf_test_5_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Fifth unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_5 !! Fifth unit test. use jf_test_5_mod , only : test_5 implicit none integer :: n_errors n_errors = 0 call test_5 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_5","tags":"","loc":"program/jf_test_5.html","title":"jf_test_5 – JSON-Fortran"},{"text":"Uses: jf_test_6_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Sixth unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_6 !! Sixth unit test. use jf_test_6_mod , only : test_6 implicit none integer :: n_errors n_errors = 0 call test_6 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_6","tags":"","loc":"program/jf_test_6.html","title":"jf_test_6 – JSON-Fortran"},{"text":"Uses: jf_test_7_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Seventh unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_7 !! Seventh unit test. use jf_test_7_mod , only : test_7 implicit none integer :: n_errors n_errors = 0 call test_7 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_7","tags":"","loc":"program/jf_test_7.html","title":"jf_test_7 – JSON-Fortran"},{"text":"Uses: jf_test_8_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Eighth unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_8 !! Eighth unit test. use jf_test_8_mod , only : test_8 implicit none integer :: n_errors n_errors = 0 call test_8 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_8","tags":"","loc":"program/jf_test_8.html","title":"jf_test_8 – JSON-Fortran"},{"text":"Uses: jf_test_9_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Ninth unit test. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_9 !! Ninth unit test. use jf_test_9_mod , only : test_9 implicit none integer :: n_errors n_errors = 0 call test_9 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_9","tags":"","loc":"program/jf_test_9.html","title":"jf_test_9 – JSON-Fortran"},{"text":"Uses: json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(json_file) :: json logical :: found integer :: i integer :: j integer :: k Source Code program example1 use json_module type ( json_file ) :: json logical :: found integer :: i , j , k ! initialize the module call json_initialize () ! read the file call json % load_file ( filename = '../files/inputs/test1.json' ) ! print the file to the console call json % print_file () ! extract data from the file ! [found can be used to check if the data was really there] call json % get ( 'version.major' , i , found ) if ( . not . found ) stop 1 call json % get ( 'version.minor' , j , found ) if ( . not . found ) stop 1 call json % get ( 'data(1).number' , k , found ) if ( . not . found ) stop 1 ! clean up call json % destroy () if ( json_failed ()) stop 1 end program example1","tags":"","loc":"program/example1.html","title":"example1 – JSON-Fortran"},{"text":"Uses: iso_fortran_env json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(json_value), pointer :: p type(json_value), pointer :: inp Source Code program example2 use , intrinsic :: iso_fortran_env , only : wp => real64 use json_module type ( json_value ), pointer :: p , inp ! initialize the module call json_initialize () ! initialize the structure: call json_create_object ( p , '' ) ! add an \"inputs\" object to the structure: call json_create_object ( inp , 'inputs' ) call json_add ( p , inp ) !add it to the root ! add some data to inputs: call json_add ( inp , 't0' , 0.1_wp ) call json_add ( inp , 'tf' , 1.1_wp ) call json_add ( inp , 'x0' , 999 9.0000 d0 ) call json_add ( inp , 'integer_scalar' , 787 ) call json_add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) call json_add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) call json_add ( inp , 'logical_scalar' , . true .) call json_add ( inp , 'logical_vector' , [. true ., . false ., . true .]) nullify ( inp ) !don't need this anymore ! write the file: call json_print ( p , '../files/example2.json' ) !cleanup: call json_destroy ( p ) if ( json_failed ()) stop 1 end program example2","tags":"","loc":"program/example2.html","title":"example2 – JSON-Fortran"},{"text":"Uses: iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. This program is run when configuring the json-fortran build,\n to determine whether or not ISO 10646/UCS4 characters are\n supported by the compiler. Variables Type Attributes Name Initial integer, parameter :: UCS4_K = selected_char_kind(\"0\") Source Code program test_iso_10646_support use iso_fortran_env , only : output_unit , error_unit implicit none integer , parameter :: UCS4_K = selected_char_kind ( 'ISO_10646' ) if ( UCS4_K == - 1 ) then !Not supported! write ( error_unit , '(A)' ) 'Your compiler does not support ISO 10646/UCS4 characters!' write ( error_unit , '(A)' ) 'JSON-Fortran must/will be configured to use the \"DEFAULT\"' write ( error_unit , '(A)' ) 'character set. (Should be \"ASCII\" on a reasonable system.)' stop 2 else write ( error_unit , '(A)' ) 'Congratulations! Your compiler supports ISO 10646/UCS4!' write ( error_unit , '(A)' ) 'JSON-Fortran may be configured to enable UCS4 support.' write ( output_unit , '(A)' ) 'UCS4_SUPPORTED' end if end program test_iso_10646_support","tags":"","loc":"program/test_iso_10646_support.html","title":"test_iso_10646_support – JSON-Fortran"},{"text":"Current Stable Release The latest stable release is 4.2.0 . 1 Past Releases Documentation for official, tagged releases can be found here , including the changelog , and download\nlinks. Development Documentation Additional documentation useful to JSON -Fortran contributors can be\nfound here , including contributing guidelines\nand test coverage reports. General Documentation A README , the same one that's posted on GitHub , can be found here . Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page//index.html","title":"Additional Documentation – JSON-Fortran"},{"text":"JSON -Fortran A Fortran 2008 JSON API Table of Contents JSON -Fortran Status Brief description Download Building the library Example Usage Reading JSON from a file Reading JSON from a string Modifying variables in a JSON file Writing a JSON file Building a JSON file from scratch Documentation Contributing License Miscellaneous Status Take a look at the CHANGELOG for a list of changes since the latest release. top Brief description A user-friendly and object-oriented API for reading and writing JSON files, written in\nmodern Fortran.  The source code is a single Fortran module file ( json_module.F90 ). top Download Download the official versioned releases here .\nOr, get the latest development code from the master branch here . NEWS: As of June 7, 2015, json-fortran can be\ndownloaded and installed with the homebrew package\nmanager on Mac OS X. Once homebrew is installed,\nmake sure that the formulae are up to date, view the package options\nand caveats, and install the json-fortran formula : brew update\nbrew info json-fortran\nbrew install --with-unicode-support json-fortran Please note , if you wish to support usage of json-fortran with\nmultiple Fortran compilers, please follow the CMake installation\ninstructions below, as the homebrew installation is only intended to\nsupport a single Fortran compiler. Cheers! top Building the library The code requires a Fortran compiler that supports\nvarious Fortran 2003 and Fortran 2008 features such as: allocatable\nstrings, newunit , generic , class , and abstract interface .\nIt has been successfully compiled with the Intel Fortran compiler\n13.1.0 (and greater) and the recent 4.9 release of the GNU gfortran\ncompiler . It has also\nbeen reported that the library can be built (using the CMake build\nscript) with the NAG Fortran compiler 6.0 Currently, several ways are provided to build the jsonfortran library\n(libjsonfortran). A build script, build.sh is provided in the project root directory. This script uses FoBiS to build the json-fortran library and the unit tests.  Edit the script to use either the Intel Fortran Compiler or Gfortran .  Note that version 1.2.5 of FoBiS (or later) is required. A Visual Studio project is included for building the library (and unit tests) on Windows with the Intel Fortran Compiler.  The project has been tested with Visual Studio 2010 and 2013. A CMake build\nsystem is provided. This build system has been tested on Mac and Linux\nusing the Intel Fortran Compiler, gfortran 4.9, and NAG Fortran 6.0. It has not been\ntested on Windows. This CMake based build provides an install target,\nand exports from both the install location and the build location so\nthat building and using json-fortran in another CMake based project is\ntrivial. To get started with the CMake based build, set the\nenvironment variable FC to point to your Fortran compiler, and\ncreate a build directory. Then (cmake-gui|ccmake|cmake)\n/path/to/json-fortran-root to configure, make to build and make\ninstall to optionally install. As long as the project is built with\nCMake, other CMake projects can find it and link against it. For example,\nif you have a second copy of the json-fortran project tree, and want to build the unit tests\nlinking against those compiled/installed by the first copy: cmake_minimum_required ( VERSION 2.8.8 FATAL_ERROR ) enable_language ( Fortran ) project ( jf_test NONE ) find_package ( jsonfortran- ${ CMAKE_Fortran_COMPILER_ID } 4.2.0 REQUIRED ) include_directories ( \"${jsonfortran_INCLUDE_DIRS}\" ) file ( GLOB JF_TEST_SRCS \"src/tests/jf_test_*.f90\" ) foreach ( UNIT_TEST ${ JF_TEST_SRCS } ) get_filename_component ( TEST ${ UNIT_TEST } NAME_WE ) add_executable ( ${ TEST } ${ UNIT_TEST } ) target_link_libraries ( ${ TEST } jsonfortran-static ) # or for linking against the dynamic/shareed library: # target_link_libraries ( ${TEST} jsonfortran ) # instead endforeach () top Example Usage In this section the basic functionality of the JSON -Fortran library is illustrated. Reading JSON from a file Reading a JSON file and getting data from it is fairly\nstraightforward using the json_file class.  Here is an example.  See unit tests 1 and 3-6\nfor more examples. The source files may be found in src/tests/ . program example1 use json_module type ( json_file ) :: json logical :: found integer :: i , j , k ! initialize the module call json_initialize () ! read the file call json % load_file ( filename = '../files/inputs/test1.json' ) ! print the file to the console call json % print_file () ! extract data from the file ! [found can be used to check if the data was really there] call json % get ( 'version.major' , i , found ) if ( . not . found ) stop 1 call json % get ( 'version.minor' , j , found ) if ( . not . found ) stop 1 call json % get ( 'data(1).number' , k , found ) if ( . not . found ) stop 1 ! clean up call json % destroy () if ( json_failed ()) stop 1 end program example1 top Reading JSON from a string JSON can also be read directly from a character string like so: call json % load_from_string ( '{\"name\": \"Leonidas\"}' ) top Modifying variables in a JSON file After reading a JSON file, if you want to change the values of some of the variables, you can use the update method.  For the example above: ! [found can be used to check if the data was really there] call json % update ( 'version.major' , 9 , found ) !change major version to 9 call json % update ( 'version.minor' , 0 , found ) !change minor version to 0 call json % update ( 'version.patch' , 0 , found ) !change patch to 0 top Writing a JSON file To print the JSON file (either to a file or the console), the print_file method can be used.  For the above example: call json % print_file () !prints to the console call json % print_file ( iunit ) !prints to the file connected to iunit top Building a JSON file from scratch Constructing a JSON file element by element is slightly more complicated and involves the use\nof json_value pointers.  For more examples see unit tests 2, 4 and 7 in src/tests/ . program example2 use , intrinsic :: iso_fortran_env , only : wp => real64 use json_module type ( json_value ), pointer :: p , inp ! initialize the module call json_initialize () ! initialize the structure: call json_create_object ( p , '' ) ! add an \"inputs\" object to the structure: call json_create_object ( inp , 'inputs' ) call json_add ( p , inp ) !add it to the root ! add some data to inputs: call json_add ( inp , 't0' , 0.1_wp ) call json_add ( inp , 'tf' , 1.1_wp ) call json_add ( inp , 'x0' , 999 9.0000 d0 ) call json_add ( inp , 'integer_scalar' , 787 ) call json_add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) call json_add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) call json_add ( inp , 'logical_scalar' , . true .) call json_add ( inp , 'logical_vector' , [. true ., . false ., . true .]) nullify ( inp ) !don't need this anymore ! write the file: call json_print ( p , '../files/example2.json' ) !cleanup: call json_destroy ( p ) if ( json_failed ()) stop 1 end program example2 The code above produces the file: { \"inputs\" : { \"t0\" : 0.1E+0 , \"tf\" : 0.11E+1 , \"x0\" : 0.9999E+4 , \"integer_scalar\" : 787 , \"integer_array\" : [ 2 , 4 , 99 ], \"names\" : [ \"aaa\" , \"bbb\" , \"ccc\" ], \"logical_scalar\" : true , \"logical_vector\" : [ true , false , true ] } } top Documentation The API documentation for the latest release version can be found here .  The\ndocumentation can also be generated by processing the source files\nwith FORD .  Note that both the\nshell script and CMake will also generate these files automatically in the documentation folder, assuming you have FORD installed. top Contributing Want to help?  Take a quick look at our contributing guidelines then claim something in the \"ready\" column on our Waffle.io and Fork. Commit. Pull request. top License The json-fortran source code and related files and documentation are distributed under a permissive free software license (BSD-style).  See the LICENSE file for more details. top Miscellaneous This code is a fork and extensive upgrade of the Fortran 95 FSON code. The reason for the split was to be able to incorporate object-oriented and other nice features of the Fortran 2003 and 2008 standards.  Many thanks to the original authors of FSON. For more information about JSON , see: http://www.json.org/ json-fortran on Travis CI json-fortran on Waffle.IO json-fortran on Codecov.IO top Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/./README.html","title":"Github README – JSON-Fortran"},{"text":"This page is a place to collect resources which are useful to JSON -Fortran contributors and developers. Contributing The guidelines for contributing to JSON -Fortran can be found here . Please read these before posting issues or opening pull requests . Also,\nplease carefully read the LICENSE before using JSON -Fortran in an application, or contributing code. Test Coverage Information The best place to start when trying to increase test coverage, is to\nlook at the procedure level coverage report automatically generated by FoBiS.py . If all procedures are\nlisted as covered, then please take a look at the Codecov.io coverage suggestions . Scripts Scripts used to build and test JSON -Fortran. This is a partial list of\nscripts used in building and testing JSON -Fortran, as well as\ndeploying documentation and managing test coverage information. build.sh .travis.yml deploy.sh gccr.pl Release Checklist This is a\nchecklist of tasks to be performed when tagging a new release of JSON -Fortran. The current stable version is 4.2.0 . Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/index.html","title":"Development Resources – JSON-Fortran"},{"text":"Contributing to JSON -Fortran Looking to contribute something to JSON -Fortran ? Here's how you can help. Table of Contents Key Branches Filing issues Outstanding Work Pull Requests Coding Standards Key Branches master is the latest, development version and all efforts should be made to keep it stable. top Filing issues Before filing a new issue , please perform a search to see if that issue has already been filed by someone else, and whether or not a solution exists. If you are experiencing the same issue as one that's already posted, please leave any additional comments and information under the existing issue. If your issue is related to a previous issue, but substantively different, file a new issue and include a mention of the related issue in text, using Jib's #<issue-number> syntax. When filing an issue please try to include all of the following information Problem description: What behavior are you seeing that you think is erroneous Installation method: Did you build the code with one of the included build scripts? Some other way? Install from a binary package? What type of system you are on: E.g., 64 bit Intel Mac OS X 10.10.2 (Yosemite) or x86_64 Ubuntu 14.04 LTS (Trusty Tahr) If applicable, what compiler you used, and any non-standard options or configurations that were used. All steps required to reproduce the problem top Outstanding Work Take a look at the issues to see if there is an issue you'd like to help address. Issues with the ready label or in the ready column on waffle.io are issues that are ready to be dealt with. (i.e., They are not blocked by other dependencies and are higher priority.) Increasing the test coverage is another helpful way to\n  contribute. Please take a look at the test coverage page for a list of uncovered procedures, and at the Codecov.io suggestions page to find procedures and lines of code that are still uncovered by the unit tests . It\n  is worth pointing out that the majority of uncovered procedures are\n  internal, overloaded procedures and can only be exercised by calling\n  the corresponding generic procedure with input arguments that will\n  resolve to the specific procedure in question. Let's keep the\n  following graph trending upwards! top Pull Requests Try not to pollute your pull request with unintended changes–keep them simple and small Pull requests should address one issue at a time, and each commit should be a set of self contained, related changes. If you forget something in a commit, please use git rebase -i <ref>&#94; to amend and/or squash erroneous commits. Here <ref> is the reference to to oldest commit needing to be modified (SHA, or HEAD~4 , etc.) Each commit should compile, and ideally pass the tests. Very complicated new features or fixes, may have commits that don't pass tests, if otherwise the commit history would include far to many changes in any given commit. Use an interactive rebase to fix any of these issues, as described above. Each commit should have a concise, descriptive message following the\n  guidelines laid out here . Make sure to document your changes in the CHANGELOG under the 'unreleased' heading. Pull requests should always be based on the upstream master, jacobwilliams/json-fortran:master . Please rebase your branch on top\nof the latest upstream master. Assuming you are on your branch and you've added the upstream remote by running something like: git remote add upstream git://github.com/jacobwilliams/json-fortran.git You can accomplish this by running: git rebase upstream/master Create a branch in your fork with a descriptive name that also includes the issue number , if applicable. For example, after forking the repo, you can run something like git checkout -b Unicode-support-issue-35 before starting work on issue #35 : Unicode support When you're content with your changes, your commits are clean, self contained, with concise descriptive messages, and your changes compile and pass the tests, submit a pull request. We will review your changes, and may ask for certain modifications to be made. Pull requests are tested by our travis-ci continuous integration system, and any errors uncovered will need to be fixed before the pull request can be merged into master. The JSON -Fortran library and associated documentation is released under a BSD style license .  By submitting a pull request, you are agreeing to release your code under the same license.  Note that code with GPL or other \"copyleft\" style licenses will not be accepted. top Coding Standards Each commit should address a single logical change and code base transformation. Each commit must compile. Each commit should pass the tests unless the feature being implemented or bug being fixed requires extensive changes that would result in a commit with too many different changes. Each pull request should ensure that the proper unit tests have\n  been added to cover at least 90% of new or changed code and that the\n  overall coverage continues to increase. New tests are added to the src/tests directory and are named jf_test_<#>.[Ff]90 . Each test is a stand alone Fortran program\n  which will automatically be compiled and linked against the JSON -Fortran library so long as it follows this naming\n  convention. If any of the tests fail, the test program should exit\n  with a non-zero return status, using the stop 2 intrinsic\n  statement. (The Fortran standard does not require the 'processor' to\n  have or set a return value, but in practice all compilers respect\n  this convention. An integer other than 2 may be used, so long as\n  it is non-zero and supported by the processor.) No extraneous white spaces are allowed to be introduced at line endings and all non binary files should end with a single new line. Run git config core.whitespace trailing-space,space-before-tab,blank-at-eol,blank-at-eof to setup the whitespace rules from within your fork, and then check for white space errors with git diff --check to see if you have accidentally introduced white space errors before committing. (You can also enable the sample pre-commit hook that ships with git, to prevent you from committing changes that introduce white space errors. See this stackoverflow question ) for some tips on preventing the introduction of whitespace errors. Please adhere to the code indentation and formatting as it currently exists, aligning common elements vertically, etc. Tab characters are not allowed. Indentations should be done with 4 space characters. Do NOT allow your editor to make a bunch of indentation or white space changes, that will introduce non-substantive changes on lines that you have not actually edited. The coding style is modern free-form Fortran, consistent with the Fortran 2008 standard.  Note that the two supported compilers (ifort and gfortran) do not currently include the entire Fortran 2008 standard. Therefore, only those language features supported by Gfortran 4.9 and Intel 13.1.0 are currently allowed.  This also means that previous versions of these compilers are not supported, and major changes to the code to support earlier compilers (or Fortran 95) will not be accepted.  At some point in the future (when compiler support has improved), all Fortran 2008 features will be allowed. All subroutines and functions must be properly documented.  This includes useful inline comments as well as comment blocks using the FORD syntax. For simplicity, JSON -Fortran currently consists of one module file. It is not envisioned that it will ever need to expand to include multiple files (if it does, there would need to be a very good reason). top Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/CONTRIBUTING.html","title":"Contributing Guidelines – JSON-Fortran"},{"text":"JSON -Fortran: A Fortran 2008 JSON API https://github.com/jacobwilliams/json-fortran Copyright (c) 2014-2015, Jacob Williams\nAll rights reserved. Redistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution. The names of its contributors may not be used to endorse or promote products\n  derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Original FSON License: Copyright (c) 2012 Joseph A. Levin Permission is hereby granted, free of charge, to any person obtaining a copy of this\nsoftware and associated documentation files (the \"Software\"), to deal in the Software\nwithout restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or\nsubstantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\nOR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE. Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/LICENSE.html","title":"JSON-Fortran License – JSON-Fortran"},{"text":"Below is the build script used to build JSON -Fortran using FoBiS.py . #!/bin/bash # #  NAME #    build.sh # #  DESCRIPTION #    Build the JSON-Fortran library and unit tests. # #  USAGE #    build.sh [--compiler {intel|gnu|<other>}] [--cflags '<custom compiler flags here>'] #             [--coverage [{yes|no}]] [--profile [{yes|no}]] [--skip-tests [{yes|no}]] #             [--skip-documentation [{yes|no}]] [--enable-unicode [{yes|no}]] [--help] #             [--clean] # #    By default, if invoked without any flags, this build script will build the #    JSON-Fortran library using gfortran, #        without : #            unicode support #            coverage flags #            profiling flags #        with : #            unit tests enabled #            documentation (if FORD is installed) # #     More recent (right-most) flags will override preceding flags #     flags: #        --compiler : gnu or gfortran for gfortran, intel or ifort for intel compiler #                     A custom compiler may also be specified here, e.g. ftn # #        --cflags : Enter any aditiol/custom compiler flags here and make sure they are #                   properly quoted # #        --help : Print a usage message and exit. # #        --clean : Delete generated files and clean up after builds # # #        The following flags all (optionally) accept an argument, \"yes\" or \"no.\" If #        no argument is passed, \"yes\" will be assumed. # #        --enable-unicode [{yes|no}]: Request that the JSON-Fortran be built with (or #                                     without) unicode/UCS4 support. If your compiler #                                     does NOT support ISO 10646/UCS4 and it was #                                     requested, then a warning is printed and the #                                     library is built without UCS4 support. # #        --coverage [{yes|no}]: Compile the library and tests with code coverage enabled #                               or disabled. # #        --profile [{yes|no}]: Compile the library and tests with code profiling enabled #                              or disabled # #        --skip-tests [{yes|no}]: Skip (or don't skip) building and running the json- #                                 fortran unit tests # #        --skip-documentation [{yes|no}]: Skip (or don't skip) building the json- #                                         fortran documentation using FORD # #  REQUIRES #    FoBiS.py : https://github.com/szaghi/FoBiS      [version 1.2.5 or later required] #    FORD     : https://github.com/cmacmackin/ford   [version 3.0.2 is the one tested] # #  AUTHOR #    Jacob Williams : 12/27/2014 # set -e FORDMD = 'json-fortran.md' # FORD options file for building documentation DOCDIR = './doc/' # build directory for documentation PAGESDIR = './pages/' # Directory for FORD \"pages\" SRCDIR = './src/' # library source directory TESTDIR = './src/tests/' # unit test source directory INTROSPECDIR = './src/tests/introspection/' # pre compile configuration tests directory UCS4TESTCODE = 'test_iso_10646_support.f90' BINDIR = './bin/' # build directory for unit tests LIBDIR = './lib/' # build directory for library MODCODE = 'json_module.F90' # json module file name LIBOUT = 'libjsonfortran.a' # name of json library # The following warning might be triggered by ifort unless explicitly silenced: # warning #7601: F2008 standard does not allow an internal procedure to be an actual argument procedure name. (R1214.4). # In the context of F2008 this is an erroneous warning. # See https://prd1idz.cps.intel.com/en-us/forums/topic/486629 INTELCOMPILERFLAGS = '-c -O2 -warn -stand f08 -diag-disable 7601 -diag-disable 4013 -diag-disable 5142 -traceback' #INTELCOMPILERFLAGS='-c -O2 -warn -traceback -stand f08 -assume protect_parens -assume buffered_io -check all' GNUCOMPILERFLAGS = '-c -O2 -fbacktrace -Wall -Wextra -Wno-maybe-uninitialized -Wno-unused-function -pedantic -std=f2008 -fno-omit-frame-pointer' FCOMPILER = 'gnu' #Set default compiler to gfortran # command line argument parsing # N.B.: Arguments appearing later in the list take precidence over those appearing earlier. #       e.g., \"./build.sh --compiler intel --coverage no --compiler gnu --coverage\" will #       perform the build with the GFORTRAN compiler, and coverage analysis script_name = \" $( basename $0 ) \" # usage message print_usage () { echo -e \"\\n\\nUsage:\\n\" echo -e \" ${ script_name } [--compiler {intel|gnu|<other>}] [--cflags '<custom compiler flags here>']\\n\\ [--coverage [{yes|no}]] [--profile [{yes|no}]] [--skip-tests [{yes|no}]]\\n\\ [--skip-documentation [{yes|no}]] [--enable-unicode [{yes|no}]] [--help]\" echo \"\" echo -e \"Any flags that take an optional yes or no argument will default to 'yes' when no\\n\\ argument is passed. Additionally, A custom compiler may be passed to the 'compiler'\\n\\ flag, but appropriate 'cflags' should also be passed to the script.\\n\\n\" } while [ \" $#\" -ge \" 1 \" ]; do # Get command line arguments while there are more left to process key=\" $1 \" # Command line args are key-value pairs or value-less keys case $key in #find known keys --compiler) #pick the compiler. Defaults to gfortran, but intel or custom compilers can be used case \" $2 \" in intel|Intel|INTEL|ifort) FCOMPILER='Intel' FCOMPILERFLAGS=\" $INTELCOMPILERFLAGS \" shift ;; gnu|Gnu|GNU|gfortran|Gfortran|GFortran|GFORTRAN) FCOMPILER='gnu' FCOMPILERFLAGS=\" $GNUCOMPILERFLAGS \" shift ;; *) FCOMPILER=\" custom \" echo \" Warning: Trying to build with unsupported compiler, $2 . \" 1>&2 echo \" Please ensure you set appropriate --cflags and ( single ) quote them \" 1>&2 FC=\" $2 \" shift ;; esac ;; --cflags) FCOMPILERFLAGS=\" $2 \" # no good way to check that the user didn't do something questionable shift ;; --enable-unicode) case $2 in yes|Yes|YES) TRY_UNICODE=\" yes \" shift ;; no|No|NO) TRY_UNICODE=\" no \" shift ;; *) TRY_UNICODE=\" yes \" # don't shift; $2 is next arg ;; esac ;; --coverage) # enable coverage case $2 in yes|Yes|YES) CODE_COVERAGE=\" yes \" shift ;; no|No|NO) CODE_COVERAGE=\" no \" shift ;; *) CODE_COVERAGE=\" yes \" # don't shift because $2 is some other flag ;; esac ;; --profile) #nable profiling case $2 in yes|Yes|YES) CODE_PROFILE=\" yes \" shift ;; no|No|NO) CODE_PROFILE=\" no \" shift ;; *) CODE_PROFILE=\" yes \" # don't shift because $2 is some other flag ;; esac ;; --skip-tests) # skip tests case $2 in yes|Yes|YES) JF_SKIP_TESTS=\" yes \" shift ;; no|No|NO) JF_SKIP_TESTS=\" no \" shift ;; *) JF_SKIP_TESTS=\" yes \" ;; esac ;; --skip-documentation) case $2 in yes|Yes|YES) JF_SKIP_DOCS=\" yes \" shift ;; no|No|NO) JF_SKIP_DOCSS=\" no \" shift ;; *) JF_SKIP_DOCS=\" yes \" ;; esac ;; --help) print_usage exit 0 ;; --clean) rm -r src{,/tests}/*.o $DOCDIR * $LIBDIR * $BINDIR * *.gcov* ;; *) echo \" Unknown flag, \\\" $1 \\\" , passed to ${ script_name } ! \" 2>&1 print_usage exit 1 ;; esac shift # look at next argument done # with argument parsing loop # if no compiler selected, then we're defaulting to gnu, and need to check that the cflags are set if [ \" $FCOMPILER \" = 'gnu' ] && [ -z \" $FCOMPILERFLAGS \" ]; then FCOMPILERFLAGS=\" $GNUCOMPILERFLAGS \" fi if [[ $CODE_COVERAGE == [yY]* ]]; then echo \" Trying to compile with code coverage instrumentation. \" COVERAGE=\" -coverage \" fi if [[ $CODE_PROFILE == [yY]* ]]; then echo \" Trying to compile with code profiling instrumentation. \" PROFILING=\" -profile \" fi if [[ $FCOMPILER == custom ]]; then echo \" Trying to compile with custom compiler, $FC \" CUSTOM=\" -fc $FC \" fi if [[ $TRY_UNICODE == [yY]* ]]; then echo \" Trying to compile library with Unicode/UCS4 support \" FoBiS.py build -ch -compiler ${ FCOMPILER } ${ CUSTOM } -cflags \" ${ FCOMPILERFLAGS } \" -dbld \" ${ BINDIR } \" -s \" ${ INTROSPECDIR } \" -dmod ./ -dobj ./ -t ${ UCS4TESTCODE } -o ${ UCS4TESTCODE %.f90 } -colors if \" ${ BINDIR } / ${ UCS4TESTCODE %.f90 } \"; then DEFINES=\" -DUSE_UCS4 -Wunused-function \" fi fi #build the stand-alone library: echo \"\" echo \" Building library... \" FoBiS.py build -ch -compiler ${ FCOMPILER } ${ CUSTOM } -cflags \" ${ FCOMPILERFLAGS } ${ DEFINES } \" ${ COVERAGE } ${ PROFILING } -dbld ${ LIBDIR } -s ${ SRCDIR } -dmod ./ -dobj ./ -t ${ MODCODE } -o ${ LIBOUT } -mklib static -colors #build the unit tests (uses the above library): if [[ $JF_SKIP_TESTS != [yY]* ]]; then echo \"\" echo \" Building unit tests... \" # FoBiS.py PR #45 work around [ -d \" $BINDIR \" ] || mkdir \" $BINDIR \" for TEST in \" ${ TESTDIR %/ } \"/jf_test_*.[fF]90; do THIS_TEST= ${ TEST ##*/ } echo \" Build ${ THIS_TEST %.[fF]90 } \" FoBiS.py build -ch -compiler ${ FCOMPILER } ${ CUSTOM } -cflags \" ${ FCOMPILERFLAGS } ${ DEFINES } \" ${ COVERAGE } ${ PROFILING } -dbld ${ BINDIR } -s ${ TESTDIR } -i ${ LIBDIR } -libs ${ LIBDIR } / ${ LIBOUT } -dmod ./ -dobj ./ -t ${ THIS_TEST } -o ${ THIS_TEST %.[fF]90 } -colors done else echo \" Skip building the unit tests since \\$ JF_SKIP_TESTS has been set to 'true' . \" fi # Run all the tests unless $JF_SKIP_TESTS echo \"\" if [[ $JF_SKIP_TESTS != [yY]* ]] ; then echo \" Running tests... \" cd \" $BINDIR \" OLD_IGNORES=\" $GLOBIGNORE \" GLOBIGNORE='*.*' # for TEST in jf_test_*; do # It would be nice to run json output printed to stdout through jsonlint, however, # some tests output more than one json structure and these need to be split echo \" Running ${ TEST } \" ./ ${ TEST } done cd - GLOBIGNORE=\" $OLD_IGNORES \" if [[ $CODE_COVERAGE = [yY]* ]] ; then [ -f json_module.F90.gcov ] && rm json_module.F90.gcov gcov -o $LIBDIR ${ SRCDIR }${ MODCODE } if [[ $TRY_UNICODE = [yY]* ]] ; then # gcov/gfortran bug work around awk -F':' '{line=\"\"; for(i=2;i<=NF;i++){line=line\" : \" $i }; if (NR > 1) print $1 prevline; prevline=line}; END{print \" - \"prevline}' json_module.F90.gcov > json_module.F90.gcov.fixed && \\ mv json_module.F90.gcov{.fixed,} # rename so we can merge coverage info mv json_module.F90.gcov json_module-unicode.F90.gcov else # rename so we can merge coverage info mv json_module.F90.gcov json_module-no-unicode.F90.gcov fi if [ -f json_module-unicode.F90.gcov ] && [ -f json_module-no-unicode.F90.gcov ]; then # merge them ./pages/development-resources/gccr.pl -n -c json_module-no-unicode.F90.gcov no-unicode \\ json_module-unicode.F90.gcov unicode > json_module.F90.gcov else cp json_module*-unicode.F90.gcov json_module.F90.gcov fi FoBiS.py rule -gcov_analyzer . sed -i\" bak \" -E 's; \\*\\*([a-zA-Z]+[a-zA-Z0-9_]*)\\*\\*; \\*\\*[[\\1]]\\*\\*;' json_module.F90.gcov.md sed -i\" bak \" -E 's;, line ([0-9]+);, line [\\1](https://github.com/jacobwilliams/json-fortran/blob/master/src/json_module.F90#L\\1);' json_module.F90.gcov.md gcov -o $BINDIR ${ TESTDIR } *.[Ff]90 fi else echo \" Skip running the unit tests since \\$ JF_SKIP_TESTS has been set to ${ JF_SKIP_TESTS } . \" fi #build the documentation with ford (if present): echo \"\" if [[ $JF_SKIP_DOCS != [yY]* ]]; then if hash ford 2>/dev/null; then echo \" Building documentation... \" [[ $TRY_UNICODE = [yY]* ]] && MACRO_FLAG=\" -m USE_UCS4 \" ford $MACRO_FLAG -p $PAGESDIR $FORDMD else echo \" FORD not found! Install using: sudo pip install ford \" fi else echo \" Skip building documentation since \\$ JF_SKIP_DOCS has been set to ${ JF_SKIP_DOCS } . \" fi Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/build.sh.html","title":"build.sh – JSON-Fortran"},{"text":"This is the script that deploys the automatically generated FORD documentation which you are\ncurrently reading. #!/bin/bash # Script to deploy documentation after successfull build of master branch or tag # If running under travis-ci this will automatically deploy updates to the master branch's # documentation on build events for the master branch, and will add/update documentation for # any new/updated tags that are pushed. if [ \" $TRAVIS \" ] ; then #running under travis if $TRAVIS_SECURE_ENV_VARS ; then # only try to update master's development documentation if [ \" $TRAVIS_BRANCH \" = \"master\" ] && \\ [ \" $TRAVIS_PULL_REQUEST \" = \"false\" ] && \\ [ \" $( ls -A $TRAVIS_BUILD_DIR /doc ) \" ] ; then #not empty git clone --branch = gh-pages https:// ${ GH_TOKEN } @github.com/ $TRAVIS_REPO_SLUG gh-pages cd gh-pages\n        rm -r css favicon.png fonts index.html interface js lists media module page proc \\ program search.html sourcefile src tipuesearch type cp -r \" $TRAVIS_BUILD_DIR \" /doc/* .\n            git add -A # Add all the new files git commit -m \"Development documentation updated by travis job $TRAVIS_JOB_NUMBER for commits $TRAVIS_COMMIT_RANGE \" git push origin gh-pages fi # If publishing a new/updated tag, deploy it's documentation if [ \" $TRAVIS_TAG \" ] && [ \" $( ls -A $TRAVIS_BUILD_DIR /doc ) \" ] ; then #not empty cd \" $TRAVIS_BUILD_DIR \" git clone --branch = gh-pages https:// ${ GH_TOKEN } @github.com/ $TRAVIS_REPO_SLUG gh-pages\n        sed \"1 s/&#94;/version: ${ TRAVIS_TAG } \\n/\" json-fortran.md > json-fortran.tagged.md # rebuild FORD documentation without pages, with version info, wiping out any existing tag folder ford -o \"gh-pages/ $TRAVIS_TAG \" json-fortran.tagged.md cd gh-pages\n        git add -A # add all new files in $TRAVIS_TAG/ git commit -m \"Tag/release documentation updated by travis job $TRAVIS_JOB_NUMBER for tag $TRAVIS_TAG $TRAVIS_COMMIT \" git push origin gh-pages fi fi fi Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/deploy.sh.html","title":"deploy.sh – JSON-Fortran"},{"text":"Below is the source code for gccr.pl , which was downloaded from https://github.com/eel3/gccr on July 23, 2015. This script is used\nby the build.sh script to merge the code coverage\ninformation for the coverage report . #!/usr/bin/env perl # -*- coding: utf-8; tab-width: 8 -*- # vim: fileencoding=UTF-8 shiftwidth=8 softtabstop=8 tabstop=8 # # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, # 2003, 2004, 2005  Free Software Foundation, Inc. # This file is free software; the Free Software Foundation # gives unlimited permission to copy and/or distribute it, # with or without modifications, as long as this notice is preserved. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY, to the extent permitted by law; without # even the implied warranty of MERCHANTABILITY or FITNESS FOR A # PARTICULAR PURPOSE. # # version 0.4.18 : eel3 : changed shebang, fixed indent, specified emacs/vim coding system. # version 0.4.17 : eel3 : fixed error occur when print the line matched /%[&#94;%]/g # version 0.4.16 : eel3 : fixed parse error occur in line 10000 or later # version 0.4.15 : eel3 : avoided warnings caused by uninitialized variable # version 0.4.14 : eel3 : fixed line number indent size for over 99999 line # version 0.4.13 : eel3 : changed warning option # version 0.4.12 : eel3 : fixed problem that extra tab is output, and changed line number to be right-aligned # version 0.4.11 : Nick Groesz : fix potential divide by zero # version 0.4.10 : Nick Groesz : fixed summary in combined coverage, ignore function data, added copyright # version 0.4.9 : Nick Groesz : added combined reporting in print_summary(), changed usage text # version 0.4.8 : Nick Groesz : added -c option (combined coverage) # version 0.4.7 : Nick Groesz : fixed formatting, added comments # version 0.4.6 : Dickson Patton : fixed tagfile option, right justify counts # version 0.4.5 : Nick Groesz : list code generated with #define macros # version 0.4.4 : Dickson Patton : added tagfile option # version 0.4.3 : Nick Groesz : changed around internal data structures, start of version history use strict ; use warnings ; use Getopt:: Long ; # prototypes sub read_args (); # read in command line arguments sub process_files (); # run through each file sub parse_execution_data (); # parse the data from each file sub print_results (); # print gcov data sub print_summary (); # print summary (similary to gcov's summary) sub print_usage (); # print gccr usage text our $tool_name = 'gccr' ; # name of script our $version = 'gccr (GCC) 0.4.18' ; # version of script our $copyright = 'Copyright (C) 2005 Free Software Foundation, Inc. This is free software; see the source for copying conditions.  There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ' ; # copyright notice # internal data our @files ; # gcov file data # # File information: # file_number -  ranges from 0 to NUMBER OF FILES SPECIFIED - 1 # $file[file_number]{'tag'} - user specified file tag # $file[file_number]{'name'} - name of file to be read and parsed # # $file[file_number[{'data'} contains parsed gcov data # # Line information: # line_number - corresponds to the line number of the GCOV file #       and ranges from 1 to NUMBER OF LINES # $data{'line'}[line_number]{'type'} - type of line #                      Can be set to: #                       no_ex -  non-executing code (gcov meta-data, header code, code that has been #ifdef'd out) #                       line -   an executable line of code #                       branch - branch execution information #                       call -   call execution information # # $data{'line'}[line_number]{'count'} -    number of times an executable line, branch, or call was executed # $data{'line'}[line_number]{'raw'} -      raw data straight from gcov file #                          this is only populated in the first file's data structure # $data{'line'}[line_number]{'line_num'} - line number in original source code # Execution information: # $data{'line_count'} -     number of executable lines # $data{'execution_count'} -    number of executed lines our $file_count = 0 ; # number of files read our $line_count = 0 ; # number of lines in gcov data files (should be the same for each file) our $executable_total = 0 ; # number of different executable lines across all files our $executed_total = 0 ; # number of different executable lines across all files that were executed # options our $opt_combined = 0 ; our $opt_help = 0 ; # help option our $opt_version = 0 ; # version option our @tag_files = (); # tagfile(s) option our $opt_nosummary = 0 ; # do not print summary read_args (); process_files (); print_results (); unless ( $opt_nosummary ) { print_summary (); } # Summary:  read command line arguments: # Parameters:   none # Return:   none sub read_args () { unless ( GetOptions ( 'combined' => \\ $opt_combined , 'help' => \\ $opt_help , 'no-summary' => \\ $opt_nosummary , 'tagfile|file=s' => \\ @tag_files , 'version' => \\ $opt_version , ) ) { # if GetOptions returns FALSE, then incorrect options were specified # exit with error print_usage (); exit ( 1 ); } if ( $opt_help ) { print_usage (); exit ( 0 ); } if ( $opt_version ) { print \"$version\\n\" ; print \"$copyright\\n\" ; exit ( 0 ); } # if any number of tag files were specified, then we read tagfiles instead of command line arugments if ( scalar ( @tag_files )) { @files = & read_tagfiles ( @tag_files ); } else { # number of file arguments + number of tag arguments should equal an even number if ( @ARGV % 2 == 1 ) { print ( \"ERROR: file count does not match tag count\\n\" ); exit ( 1 ); } my $i = 0 ; while ( $ARGV [ $i ]) { push @files , { name => $ARGV [ $i ], tag => $ARGV [ $i + 1 ]}; $i += 2 ; } } $file_count = scalar ( @files ); if ( $file_count < 2 ) { print ( \"ERROR: at least two files must be specified\\n\" ); exit ( 1 ); } } # Summary:  read tagfiles specifie dwith the -t option # Parameters:   array of names of tagfiles # Return:   array of name/tag hashes sub read_tagfiles ($) { my @tag_files = @_ ; my @files ; my $l = 0 ; # count of --tagfile=___ options my $m = 0 ; # count of line in the current tagfile foreach my $file ( @tag_files ) { $l ++ ; open ( TAGFILE , $file ) || die \"ERROR: on open of tagfile $l, $file: ($!)\\n\" ; while ( <TAGFILE> ) { $m ++ ; chomp $_ ; if ( /(&#94;([&#94; ]+) *(.*)$)/ ) { push @files , { name => $2 , tag => $3 }; } else { die \"ERROR: invalid file-tag pair on line $m of tagfile $l\\n\" ; } } close ( TAGFILE ); } return ( @files ); } # Summary:  run through all the gcov files and call the parsing function # Parameters:   none # Return:   none sub process_files () { # the first file is used to gather raw data $files [ 0 ]{ 'data' } = parse_execution_data ( $files [ 0 ]{ 'name' }, 1 ); for ( my $i = 1 ; $i < $file_count ; $i ++ ) { $files [ $i ]{ 'data' } = parse_execution_data ( $files [ $i ]{ 'name' }, 0 ); } } # Summary:  parse the gcov file, populating the %data structure # Parameters:   name of file to parse | boolean indicating whether raw (original gcov) data should be saved #       save_raw is set to 1 on the first file parse and set to zero thereafter # Returns:  reference to data hash sub parse_execution_data () { my ( $file , $save_raw ) = @_ ; my %data ; $data { 'line_count' } = 0 ; # number of executable lines in file $data { 'execution_count' } = 0 ; # number of lines that were executed in file stat ( $file ); if ( ! ( - r _ )) { die ( \"ERROR: cannot read file: $file\\n\" ); } if ( ! ( - f _ )) { die ( \"ERROR: not a plain file: $file\\n\" ); } open ( FILE_HANDLE , $file ) || die ( \"ERROR: cannot open file $file: $!\" ); my $file_line_num = 0 ; while ( <FILE_HANDLE> ) { my $line = $_ ; $file_line_num ++ ; chomp $line ; if ( $line =~ /&#94;\\s+-:\\s*(\\d+):(.*)/ ) { # line is gcov preamble or non-executing code my $line_num = $1 ; my $raw = $2 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'no_ex' ; $data { 'line' }[ $file_line_num ]{ 'line_num' } = $line_num ; if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $2 ; } } elsif ( $line =~ /&#94;\\s+#####:\\s*(\\d+):(.*)/ ) { # line was not executed my $line_num = $1 ; my $raw = $2 ; $data { 'line' }[ $file_line_num ]{ 'count' } = 0 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'code' ; $data { 'line' }[ $file_line_num ]{ 'line_num' } = $line_num ; $data { 'line_count' } ++ ; if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $raw ; } } elsif ( $line =~ /&#94;\\s+(\\d+):\\s*(\\d+):(.*)/ ) { # line was executed my $count = $1 ; my $line_num = $2 ; my $raw = $3 ; $data { 'line' }[ $file_line_num ]{ 'count' } = $count ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'code' ; $data { 'line' }[ $file_line_num ]{ 'line_num' } = $line_num ; $data { 'line_count' } ++ ; $data { 'execution_count' } ++ ; if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $raw ; } } elsif ( $line =~ /&#94;branch\\s+(\\d+)/ ) { # line contains branch execution information my $branch_num = $1 ; $data { 'line' }[ $file_line_num ]{ 'num' } = $branch_num ; if ( $line =~ /&#94;branch\\s+\\d+\\s+never executed/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = 0 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'branch' ; } elsif ( $line =~ /&#94;branch\\s+\\d+\\s+taken (\\d+)%/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = $1 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'branch' ; } if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $line ; } } elsif ( $line =~ /&#94;call\\s+(\\d+)/ ) { # line contains call execution information my $call_num = $1 ; $data { 'line' }[ $file_line_num ]{ 'num' } = $call_num ; if ( $line =~ /&#94;call\\s+\\d+\\s+never executed/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = 0 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'call' ; } elsif ( $line =~ /&#94;call\\s+\\d+\\s+returns (\\d+)%/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = $1 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'call' ; } if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $line ; } } elsif ( $line =~ /&#94;function/i ) { # function data is ignored } else { # line could not be parsed print ( \"ERROR: cannot parse line $file_line_num in file $file\\n Is this a valid gcov file?\\n\" ); exit ( 1 ); } } close ( FILE_HANDLE ); # check to see if we should save an overall line count (common to all gcov files) if ( $save_raw ) { $line_count = $file_line_num ; } return ( \\ %data ); } # Summary:  print interpolated gcov information # Parameters:   none # Return:   none sub print_results () { my $ftab = '        ' ; my $p_op = ( $line_count <= 99999 ) ? '%5d' : '%13d' ; for ( my $line_i = 1 ; $line_i <= $line_count ; $line_i ++ ) { my $raw_printed = 0 ; # boolean flag to print out the line slurped in from the gcov file my $count_sum = 0 ; # sum of executions across all files for this one line- used for combined coverage reporting my $never_exec = 1 ; # boolean flag that is set to 0 when the current line is executed or executable # in any file. used in combined coverage reporting. my $first_code_line_executed = 0 ; # boolean flag that indicates whether this is the first unique # executed line of code to be found among the gcov files for ( my $file_i = 0 ; $file_i < $file_count ; $file_i ++ ) { # Note that each file is cycled through for every line even if just the raw # data from the first file that ends up being printed. This is because the same # line may be non-executing in one file and executable in another file (because code # may be ifdef'd out). my $type = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'type' }; no warnings 'uninitialized' ; # XXX: remove warining for $type if ( $type eq 'no_ex' ) { # non-executing code unless ( $raw_printed || $opt_combined ) { printf ( \"$ftab-:$p_op:%s\\n\" , $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); $raw_printed = 1 ; } # nothing additional is printed for non-executing code } elsif ( $type eq 'code' ) { # code that is executable if ( $never_exec ) { # this code is exectuable, so we indicate that in the never_exec flag $never_exec = 0 ; # we only want the number of UNIQUE lines across files that are executable # in the executable_total flag, so this is only incremented once for all # identical lines across each file $executable_total ++ ; } unless ( $raw_printed || $opt_combined ) { printf ( \"$ftab  $p_op:%s\\n\" , $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); $raw_printed = 1 ; } my $count = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'count' }; if ( $opt_combined ) { $count_sum += $count ; if ( $first_code_line_executed == 0 && $count > 0 ) { $executed_total ++ ; $first_code_line_executed = 1 ; } } else { if ( $count == 0 ) { print '     ####' ; } else { unless ( $first_code_line_executed ) { # update the unique count of code lines executed # across all gcov files $executed_total ++ ; $first_code_line_executed = 1 ; } my $padding = 9 ; $padding -= length ( $count ); printf ( \"%*s%d\" , $padding , ' ' , $count ); } printf ( \":$p_op: \" , $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }); print \"$files[$file_i]{'tag'}\\n\" ; } } elsif ( $type eq 'branch' ) { # branch information my $count = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'count' }; if ( $opt_combined ) { $count_sum += $count ; } else { if ( $count == 0 ) { print \"branch $files[$file_i]{'data'}{'line'}[$line_i]{'num'} never executed:$files[$file_i]{'tag'}\\n\" ; } else { print \"branch $files[$file_i]{'data'}{'line'}[$line_i]{'num'} taken $count%:$files[$file_i]{'tag'}\\n\" ; } } } elsif ( $type eq 'call' ) { # call information my $count = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'count' }; if ( $opt_combined ) { $count_sum += $count ; } else { if ( $count == 0 ) { print \"call $files[$file_i]{'data'}{'line'}[$line_i]{'num'} never executed:$files[$file_i]{'tag'}\\n\" ; } else { print \"call $files[$file_i]{'data'}{'line'}[$line_i]{'num'} returns $count%:$files[$file_i]{'tag'}\\n\" ; } } } } if ( $opt_combined ) { # if the combined coverage flag is set then no information is printed in the above for loop # count information is summed into $count_sum and printed on a single line my $type = $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'type' }; no warnings 'uninitialized' ; # XXX: remove warining for $type if ( $type eq 'no_ex' || $type eq 'code' ) { # line is either non-executable or executable code if ( $never_exec ) { # code line is not executable in any file printf ( \"$ftab-:$p_op:%s\\n\" , $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); } else { # line is executable in at least one file if ( $count_sum == 0 ) { print '    #####' ; } else { my $padding = 9 ; $padding -= length ( $count_sum ); printf ( \"%*s%d\" , $padding , ' ' , $count_sum ); } printf ( \":$p_op:%s\\n\" , $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); } } elsif ( $type eq 'branch' ) { # branch information if ( $count_sum == 0 ) { print \"branch $files[0]{'data'}{'line'}[$line_i]{'num'} never executed\\n\" ; } else { my $percentage = $count_sum / $file_count ; print \"branch $files[0]{'data'}{'line'}[$line_i]{'num'} taken $percentage%\\n\" ; } } elsif ( $type eq 'call' ) { # call information if ( $count_sum == 0 ) { print \"call $files[0]{'data'}{'line'}[$line_i]{'num'} never executed\\n\" ; } else { my $percentage = $count_sum / $file_count ; print \"call $files[0]{'data'}{'line'}[$line_i]{'num'} returns $percentage%\\n\" ; } } } } } # Summary:  prints the line execution percentages for each file and a percentage for all files combined # Parameters:   none # Return:   none sub print_summary () { for ( my $file_i = 0 ; $file_i < $file_count ; $file_i ++ ) { my $file_line_count = $files [ $file_i ]{ 'data' }{ 'line_count' }; my $percentage ; if ( $file_line_count ) { $percentage = ( $files [ $file_i ]{ 'data' }{ 'execution_count' } / $file_line_count ) * 100 ; } else { $percentage = 0 ; } $percentage = sprintf ( '%.2f' , $percentage ); print \"$percentage% of $file_line_count lines executed on target $files[$file_i]{'tag'}\\n\" ; } my $overall_percentage ; if ( $executable_total ) { $overall_percentage = ( $executed_total / $executable_total ) * 100 ; } else { $overall_percentage = 0 ; } $overall_percentage = sprintf ( '%.2f' , $overall_percentage ); print \"$overall_percentage% of $executable_total lines executed across all files\\n\" ; } # Summary:  print tool usage information # Parameters:   none # Return:   none sub print_usage () { print <<END_USAGE; Usage: ./$tool_name [options] <file name> <target id> <file name> <target id> [file name] [target id]... Use $tool_name to compare gcov files generated on different platforms or targets. -h, --help                      Print this help, then exit -v, --version                   Print version number, then exit Input Options: -t, --tagfile                   Take file-tag assignments from a file, not from command-line Ouput Options: -c, --combined          Print combined coverage -n, --no-summmary       Do not print summary END_USAGE } Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/gccr.pl.html","title":"gccr.pl – JSON-Fortran"},{"text":"Coverage analysis Coverage analysis of json_module.F90 Unexecuted procedures Executed procedures Coverage analysis The following report was automatically generated from gcov output by the FoBiS.py Fortran build\ntool. gccr.pl was used to\nmerge gcov coverage\nreports, and can be obtained at https://github.com/eel3/gccr . Any\nprocedures surrounded by double square brackets below are internal\nprocedures and do not have their own documentation page–documentation\nfor these procedures is included in the documentation of the scope in\nwhich they are defined. If procedure coverage is at 100%, also have a look at the Codecov.io coverage suggestions . Coverage analysis of json_module.F90 Metrics Number of executable lines 1481 Number of executed lines 1345 91% Number of unexecuted lines 136 9% Average hits per executed line 586531 Number of procedures 174 Number of executed procedures 174 100% Number of unexecuted procedures 0 0% Average hits per executed procedure 38117 Unexecuted procedures none Executed procedures subroutine [[parse_string]] : tested 2110800 times subroutine [[destroy_json_data]] : tested 1554782 times subroutine [[json_value_create]] : tested 777476 times subroutine [[json_value_add_member]] : tested 777396 times subroutine [[to_string]] : tested 497764 times subroutine [[push_char]] : tested 279370 times subroutine [[parse_number]] : tested 139680 times subroutine [[to_integer]] : tested 100048 times function [[string_to_integer]] : tested 99864 times subroutine [[to_object]] : tested 79740 times subroutine [[to_double]] : tested 40054 times subroutine [[to_array]] : tested 39914 times function [[string_to_double]] : tested 39878 times function [[to_uni]] : tested 23085 times function [[ucs4_comp_default]] : tested 22579 times subroutine [[to_logical]] : tested 19962 times subroutine [[parse_for_chars]] : tested 19928 times subroutine [[write_it]] : tested 2935 times function [[json_failed]] : tested 685 times subroutine [[integer_to_string]] : tested 586 times function [[json_count]] : tested 573 times subroutine [[json_get_double]] : tested 512 times function [[to_uni_vec]] : tested 386 times subroutine [[real_to_string]] : tested 334 times subroutine [[compact_real_string]] : tested 334 times function [[default_join_ucs4]] : tested 292 times subroutine [[get_double_from_array]] : tested 264 times subroutine [[json_value_get_by_name_chars]] : tested 241 times subroutine [[json_value_add_integer]] : tested 240 times function [[valid_json_hex]] : tested 238 times subroutine [[escape_string]] : tested 172 times subroutine [[json_value_add_double]] : tested 170 times subroutine [[json_get_by_path]] : tested 156 times subroutine [[get_double_from_array]] : tested 120 times subroutine [[json_clear_exceptions]] : tested 96 times subroutine [[json_info]] : tested 94 times subroutine [[json_get_string_with_path]] : tested 92 times subroutine [[json_value_add_string]] : tested 86 times subroutine [[wrap_json_value_add_double]] : tested 84 times subroutine [[json_file_get_string]] : tested 80 times subroutine [[json_initialize]] : tested 80 times subroutine [[json_get_string]] : tested 72 times subroutine [[json_value_get_by_index]] : tested 62 times function [[ucs4_join_default]] : tested 62 times subroutine [[json_get_logical]] : tested 58 times subroutine [[json_value_create_object]] : tested 44 times subroutine [[wrap_json_file_get_string]] : tested 38 times subroutine [[json_value_add_logical]] : tested 36 times subroutine [[get_logical_from_array]] : tested 36 times subroutine [[json_get_array]] : tested 34 times subroutine [[json_file_destroy]] : tested 30 times subroutine [[json_get_integer]] : tested 30 times subroutine [[json_throw_exception]] : tested 28 times subroutine [[json_value_add_double_vec]] : tested 28 times subroutine [[json_get_array_with_path]] : tested 26 times subroutine [[wrap_json_value_add_string]] : tested 25 times subroutine [[json_value_add_string_vec]] : tested 24 times subroutine [[json_parse_file]] : tested 23 times subroutine [[wrap_json_value_create_object]] : tested 22 times subroutine [[json_file_load]] : tested 21 times subroutine [[wrap_json_value_add_integer]] : tested 20 times subroutine [[json_print_1]] : tested 20 times subroutine [[get_chars_from_array]] : tested 20 times subroutine [[json_parse_string]] : tested 19 times subroutine [[json_update_string]] : tested 18 times subroutine [[get_logical_from_array]] : tested 18 times subroutine [[wrap_json_value_add_logical]] : tested 17 times subroutine [[json_value_add_integer_vec]] : tested 16 times subroutine [[json_value_add_string_name_ascii]] : tested 16 times subroutine [[json_get_integer_with_path]] : tested 16 times subroutine [[json_value_to_string]] : tested 15 times subroutine [[json_file_get_integer]] : tested 14 times subroutine [[wrap_json_value_add_double_vec]] : tested 14 times subroutine [[json_file_load_from_string]] : tested 13 times subroutine [[json_file_print_to_string]] : tested 13 times subroutine [[json_file_get_object]] : tested 12 times subroutine [[json_value_add_logical_vec]] : tested 12 times subroutine [[json_get_double_vec_with_path]] : tested 12 times subroutine [[json_file_print_to_console]] : tested 10 times subroutine [[json_file_get_double_vec]] : tested 10 times subroutine [[json_value_remove]] : tested 10 times subroutine [[get_int_from_array]] : tested 10 times subroutine [[to_null]] : tested 10 times subroutine [[json_file_print_1]] : tested 8 times subroutine [[json_file_update_string]] : tested 8 times subroutine [[wrap_json_value_add_integer_vec]] : tested 8 times subroutine [[wrap_json_value_add_string_vec]] : tested 8 times subroutine [[json_get_double_with_path]] : tested 8 times subroutine [[wrap_json_file_get_integer]] : tested 7 times subroutine [[wrap_json_file_load_from_string]] : tested 6 times subroutine [[json_file_get_double]] : tested 6 times subroutine [[json_check_for_errors]] : tested 6 times subroutine [[json_update_logical]] : tested 6 times subroutine [[json_update_double]] : tested 6 times subroutine [[wrap_json_value_add_logical_vec]] : tested 6 times subroutine [[get_int_from_array]] : tested 6 times subroutine [[wrap_json_get_string_with_path]] : tested 6 times subroutine [[get_chars_from_array]] : tested 6 times subroutine [[annotate_invalid_json]] : tested 6 times subroutine [[json_print_error_message]] : tested 6 times subroutine [[wrap_json_file_get_object]] : tested 5 times subroutine [[json_file_update_logical]] : tested 4 times subroutine [[json_file_update_real]] : tested 4 times subroutine [[json_update_integer]] : tested 4 times subroutine [[json_print_2]] : tested 4 times subroutine [[wrap_json_get_by_path]] : tested 4 times subroutine [[json_get_integer_vec_with_path]] : tested 4 times subroutine [[json_get_logical_with_path]] : tested 4 times subroutine [[json_get_logical_vec_with_path]] : tested 4 times subroutine [[json_get_string_vec_with_path]] : tested 4 times subroutine [[json_value_create_array]] : tested 4 times subroutine [[json_file_print_2]] : tested 3 times subroutine [[wrap_json_file_get_double]] : tested 3 times subroutine [[wrap_json_throw_exception]] : tested 3 times subroutine [[wrap_json_update_string]] : tested 3 times subroutine [[wrap_json_parse_string]] : tested 3 times function [[initialize_json_file]] : tested 2 times subroutine [[json_file_move_pointer]] : tested 2 times subroutine [[json_file_variable_info]] : tested 2 times subroutine [[json_file_get_root]] : tested 2 times subroutine [[json_file_get_integer_vec]] : tested 2 times subroutine [[json_file_get_logical]] : tested 2 times subroutine [[json_file_get_logical_vec]] : tested 2 times subroutine [[json_file_get_string_vec]] : tested 2 times subroutine [[json_value_remove_if_present]] : tested 2 times subroutine [[json_file_update_integer]] : tested 2 times subroutine [[wrap_json_file_update_logical]] : tested 2 times subroutine [[wrap_json_file_update_real]] : tested 2 times subroutine [[wrap_json_file_update_string]] : tested 2 times subroutine [[json_value_add_string_vec_name_ascii]] : tested 2 times subroutine [[json_value_add_string_vec_val_ascii]] : tested 2 times subroutine [[json_get_integer_vec]] : tested 2 times subroutine [[json_get_double_vec]] : tested 2 times subroutine [[json_get_logical_vec]] : tested 2 times subroutine [[json_get_string_vec]] : tested 2 times subroutine [[json_value_create_logical]] : tested 2 times subroutine [[json_value_create_integer]] : tested 2 times subroutine [[json_value_create_double]] : tested 2 times subroutine [[json_value_create_string]] : tested 2 times subroutine [[json_value_create_null]] : tested 2 times subroutine [[wrap_json_value_create_array]] : tested 2 times subroutine [[wrap_json_file_variable_info]] : tested 1 times subroutine [[wrap_json_file_get_integer_vec]] : tested 1 times subroutine [[wrap_json_file_get_double_vec]] : tested 1 times subroutine [[wrap_json_file_get_logical]] : tested 1 times subroutine [[wrap_json_file_get_logical_vec]] : tested 1 times subroutine [[wrap_json_file_get_string_vec]] : tested 1 times subroutine [[wrap_json_value_remove_if_present]] : tested 1 times subroutine [[wrap_json_file_update_integer]] : tested 1 times subroutine [[json_file_update_string_name_ascii]] : tested 1 times subroutine [[json_file_update_string_val_ascii]] : tested 1 times subroutine [[wrap_json_update_logical]] : tested 1 times subroutine [[wrap_json_update_double]] : tested 1 times subroutine [[wrap_json_update_integer]] : tested 1 times subroutine [[json_update_string_name_ascii]] : tested 1 times subroutine [[json_update_string_val_ascii]] : tested 1 times subroutine [[json_value_add_string_val_ascii]] : tested 1 times subroutine [[wrap_json_value_get_by_name_chars]] : tested 1 times subroutine [[wrap_json_get_integer_with_path]] : tested 1 times subroutine [[wrap_json_get_integer_vec_with_path]] : tested 1 times subroutine [[wrap_json_get_double_with_path]] : tested 1 times subroutine [[wrap_json_get_double_vec_with_path]] : tested 1 times subroutine [[wrap_json_get_logical_with_path]] : tested 1 times subroutine [[wrap_json_get_logical_vec_with_path]] : tested 1 times subroutine [[wrap_json_get_string_vec_with_path]] : tested 1 times subroutine [[wrap_json_get_array_with_path]] : tested 1 times subroutine [[get_current_line_from_file_sequential]] : tested 1 times subroutine [[get_current_line_from_file_stream]] : tested 1 times subroutine [[wrap_json_value_create_logical]] : tested 1 times subroutine [[wrap_json_value_create_integer]] : tested 1 times subroutine [[wrap_json_value_create_double]] : tested 1 times subroutine [[wrap_json_value_create_string]] : tested 1 times subroutine [[wrap_json_value_create_null]] : tested 1 times function [[default_comp_ucs4]] : tested 1 times Report generated by [FoBiS.py](https://github.com/szaghi/FoBiS Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/json_module.F90.gcov.html","title":"Coverage Analysis – JSON-Fortran"},{"text":"When tagging a new release please follow this checklist so that the\ndocumentation will be updated correctly, and version strings will\nremain accurate. Release Checklist Make sure you are working from the master branch: git checkout master Update the CHANGELOG.md Ensure that the changes listed under Unreleased are up\n    to date and accurate. Look at the latest changes committed to GitHub since the\n    last release ,\n    4.2.0. This will only be accurate if you have\n    not yet updated __VERSION__ . If you have updated __VERSION__ then edit the URL manually to view the\n    changes. Run the github_changelog_generator as follows, and compare the output to the unreleased section of the CHANGELOG.md : github_changelog_generator -o Unreleased.md\n    --unreleased-only --bugs-label \"**Fixed issues:**\"\n    --enhancement-label \"**Enhancements:**\" --issues-label\n    \"**Fixed issues:**\" and make sure that you have a\n    16-digit GitHub token stored in the environment variable CHANGELOG_GITHUB_TOKEN . Compare generated Unreleased.md to the \"Unreleased\" section of CHANGELOG.md and make updates as needed. Rename the \"Unreleased\" section to the new version number Copy the \"Unreleased\" section header and \"Complete\n    Changeset\" link line and insert it just below the TOC In the newly inserted \"Complete Changeset\" URL replace the\n    old version number with the new version number Rename the lower \"Unreleased\" section (with all the\n    changes) to the current version Replace HEAD in the header URL with the new version\n    number Replace HEAD in the \"Complete Changeset\" link with the\n    new version number. Insert the new version section in the TOC just below the\n    \"Unreleased\" entry Add CHANGELOG.md to the git index: git add CHANGELOG.md Add an entry in pages/releases/index.md under the \"Past\n    Releases\" heading Copy/paste the most recent one listed and replace all\n    occurrences of the old version string with the new version\n    string Add pages/releases/index.md to the git index: git add pages/releases/index.md Update the version string in remaining files requiring manual edits: Edit the __VERSION__ file Edit the CMake example on line 123 of README.md Add both files to the git index: git add __VERSION__\n README.md Commit the changes to the master branch: git commit Create the tag: git tag <new version> deploy.sh will publish the documentation for the\n    latest tag from Travis-CI to\n    https://jacobwilliams.github.io/json-fortran/ new_ver / if all\n    goes according to plan Push tags and master to GitHub: git push --tags origin master Draft and publish a new GitHub Release corresponding to the new version Update the Homebrew formula Fork the Homebrew repository Change to your local Homebrew repository: cd $(brew\n    --repository)/Library/Formula Add your fork as a pushable remote: git remote add\n    YOUR_USERNAME https://github.com/YOUR_USERNAME/homebrew.git Make sure you're on the master branch: git checkout master Make sure everything is up to date: brew update (this calls git pull ) Create a new branch from the latest master branch with git\n    checkout -b YOUR_BRANCH_NAME origin/master Edit the json-fortran.rb formula with brew edit\n    json-fortran Do NOT change anything other than the URL and the SHA256\n    checksum at the top of the formula. These should be changed to\n    correspond to the new version of the compressed tarball\n    available on newly minted latest release page Test the changes to make sure that they will be accepted: brew audit --strict --online json-fortran brew rm json-fortran brew install -v json-fortran brew test -v json-fortran Add json-fortran.rb to the index ( git add json-fortran.rb ) Commit your changes with the correct commit message: git\n    commit -m \"json-fortran <new-version-string-here>\" Push changes to your fork: git push --set-upstream\n    YOUR_USERNAME YOUR_BRANCH_NAME Go to https://github.com/Homebrew/homebrew and submit a pull\n    request Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/release-checklist.html","title":"Release Checklist – JSON-Fortran"},{"text":"This is the Travis-CI script\nused to perform continuous integration testing for JSON -Fortran, and\ntrigger automatic documentation deployment. language : python python : - 2.7 sudo : false cache : apt : true pip : true directories : - $HOME /.cache/ pip - $HOME /. local addons : apt : sources : - kalakris - cmake - ubuntu - toolchain - r - test packages : - gfortran - 4.9 - binutils - cmake - python - pip - graphviz # Build matrix : Run the three build systems and tests in parallel env : global : - CHECK_README_PROGS = \"yes\" matrix : # CMake build with unit tests , no documentation , with coverage analysis # No unicode so that coverage combined with the build script will cover unicode # and non - unicode code paths - > BUILD_SCRIPT = \"mkdir cmake-build && cd cmake-build && cmake .. && make -j 4 check\" CODE_COVERAGE = \"no\" DEPLOY_DOCUMENTATION = \"no\" # build with build . sh , make documentation , run unit tests and perform coverage analysis - > BUILD_SCRIPT = \"./build.sh --coverage --skip-documentation && ./build.sh --coverage --enable-unicode\" CODE_COVERAGE = \"yes\" DEPLOY_DOCUMENTATION = \"yes\" install : - | if [[ ! - d \"$HOME/.local/bin\" ]]; then mkdir \"$HOME/.local/bin\" fi - export PATH = \"$HOME/.local/bin:$PATH\" - export FC =/ usr /bin/g fortran - 4.9 - ln - fs /usr/bin/gfortran-4.9 \"$HOME/.local/bin/g fortran \" && gfortran --version - ls -l /usr/bin/gfortran-4.9 - ln -fs /usr/bin/gcov-4.9 \" $HOME /.local/bin/g cov \" && gcov --version - | if ! which f90split; then wget http://people.sc.fsu.edu/~jburkardt/f_src/f90split/f90split.f90 && \\ gfortran -o f90split f90split.f90 && \\ mv f90split \" $HOME /.local/bin/ \" && \\ rm f90split.f90 fi - pip install --upgrade pygooglechart - pip install --upgrade graphviz - (pip install --upgrade FoBiS.py && FoBiS.py --version) - (pip install --upgrade ford && ford --version) - (pip install --upgrade git+https://github.com/dmeranda/demjson.git && jsonlint --version) before_script: - | if [[ $CHECK_README_PROGS == [yY]* ]]; then f90split README.md && \\ for f in example*.md; do mv $f src/tests/jf_test_${f%.md}.f90 done fi - | if [ \" $TRAVIS_TAG \" ]; then if [[ \" v$TRAVIS_TAG \" != \" v$ ( cat __VERSION__ ) \" ]]; then echo \" ERROR : You are trying to tag a new release but have a version missmatch in \\ ` __VERSION__ \\ ` \" false # throw an error fi fi script: - echo $BUILD_SCRIPT - bash <<<$BUILD_SCRIPT after_success: - cd $TRAVIS_BUILD_DIR - git config --global user.name \" TRAVIS - CI - for - $ ( git -- no - pager show - s -- format = '%cn' $TRAVIS_COMMIT ) \" - git config --global user.email \" $ ( git -- no - pager show - s -- format = '%ce' $TRAVIS_COMMIT ) \" - | if [[ $DEPLOY_DOCUMENTATION == [ yY ]* ]]; then ./ deploy . sh # publish docs for master branch and tags fi - ( yes | rm - r doc gh - pages ) || true # wipe out doc dirs to avoid confusing codecov - | if [[ $CODE_COVERAGE == [ yY ]* ]]; then rm json_module -* unicode . F90 . gcov || true mv json_module . F90 . gcov src / mv jf_test *.[ fF ] 90 . gcov src /tests/ bash <( curl - s https :// codecov . io / bash ) - v - X gcov fi Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/development-resources/travis.yml.html","title":".travis.yml – JSON-Fortran"},{"text":"Official Releases Latest Stable Release Past Releases Development Version Changes Between Releases Change Log Unreleased 4.2.0 (2015-08-03) 4.1.1 (2015-05-27) 4.1.0 (2015-05-05) 4.0.0 (2015-03-16) 3.1.0 (2015-02-28) 3.0.0 (2015-01-18) 2.0.0 (2014-12-27) 1.0.0 (2014-06-23) Official Releases This is where to find the documentation corresponding to an official,\ntagged release. If you are looking for the most current documentation\nof the master branch, please head back to the main page . Latest Stable Release Documentation: 4.2.0 Download: https://github.com/jacobwilliams/json-fortran/releases/latest Past Releases Note: There is currently no way to navigate back to the general/master\ndocumentation from the documentation for official releases other than\nusing the browser's back button. Feel free to bookmark this page, or\nthe main project page for convenient navigation. 4.2.0 ( FORD generated documentation) Download 4.1.1 ( ROBODoc generated documentation) Download 4.1.0 ( ROBODoc generated documentation) Download 4.0.0 ( ROBODoc generated documentation) Download 3.1.0 ( ROBODoc generated documentation) Download 3.0.0 ( ROBODoc generated documentation) Download 2.0.0 ( ROBODoc generated documentation) Download 1.0.0 ( ROBODoc generated documentation) Download Development Version Documentation for the latest development version may be found at https://jacobwilliams.github.io/json-fortran/4.2.0/index.html or generated locally using the build.sh build\nscript. Changes Between Releases Included below is the changelog–a list of significant changes\nimplemented between each release. Change Log Table of Contents Change Log Unreleased 4.2.0 (2015-08-03) 4.1.1 (2015-05-27) 4.1.0 (2015-05-05) 4.0.0 (2015-03-16) 3.1.0 (2015-02-28) 3.0.0 (2015-01-18) 2.0.0 (2014-12-27) 1.0.0 (2014-06-23) Unreleased Complete Changeset 4.2.0 (2015-08-03) Complete Changeset or Download v4.2.0 Enhancements The exception_thrown flag is now true by default before the json_initialize routine is called to initialize the module. #142 ( jacobwilliams ) Updated json_info to get name of json_value variable. #141 ( jacobwilliams ) Added a new routine ( json_traverse ) to traverse all nodes of a JSON structure #140 via PR #144 from  ( jacobwilliams ) Added FORD documentation automatic deployment via PR #137 from zbeekman Added new version release checklist, #122 via PR #137 from zbeekman Added finer control of real format printing, #117 via PR #137 from zbeekman , and #143 from jacobwilliams Removed official SCons support to facilitate faster development\n  cycle, #121 via PR #130 from zbeekman Add a CHANGELOG #120 via PR #123 from zbeekman Spell 'Fortran' correctly #118 via PR #124 from zbeekman Migrate to Codecov.io #106 via PR #107 from zbeekman CMake emulate make check and exclude tests\n  from all target #103 implemented via PR #104 from zbeekman Fixed issues: Fixed bad gcov reports being generated due to a gcov/gfortran bug, #131 via PR #137 from zbeekman Fixed inaccurate coverage reports via PR #109 from zbeekman Fixed a small consistency issue when outputting floating point\n  numbers via PR #125 Problems writing JSON to error_unit (0) due to JSON -Fortran's\n  special interpretation of unit=0 #85 fixed via PR #111 from zbeekman Broken parsing error message for empty line PR #110 ( jacobwilliams ) Merged pull requests: Documentation fixes & coverage improvements #112 ( zbeekman ) Speedier container based Travis-CI builds #130 ( zbeekman ) 4.1.1 (2015-05-27) Complete Changeset or Download v4.1.1 Enhancements Installation now possible with a Homebrew package on Mac OS X CMake install option to use a more traditional\n  Gnu install structure (to support Homebrew installation) PR #101 from zbeekman Fixed issues: Broken Travis-CI tests #99 fixed by PR #100 from zbeekman CMakeLists.txt accidentally defaulting to Unicode build due to small\n  typo #96 ,\n  fixed by PR #97 from zbeekman Merged pull requests: 4.1.0 (2015-05-05) Complete Changeset or Download v4.1.0 Enhancements: Run-time speed improvements #75 implemented in PR #93 from jacobwilliams Merged pull requests: Small formatting and addition of a unit test #95 ( jacobwilliams ) 4.0.0 (2015-03-16) Complete Changeset or Download v4.0.0 Enhancements Unicode support #35 added in PR #84 from zbeekman Automate testing of the stand alone programs listed in the README.md #67 added in PR #71 from zbeekman Automatically analyze and report test coverage info with coveralls.io and Travis-CI #63 implemented in PR #72 from zbeekman Enhanced command line user interface for build.sh build script PR #82 ( zbeekman ) Additional options and improvements made to command line interface\n  of the build.sh build script PR #88 ( zbeekman ) Added unit tests for improved unit test coverage PR #83 ( jacobwilliams ) and PR #73 ( jacobwilliams ) Fixed issues: Stack overflow in destroy for large structure #76 fixed in PR #77 from jacobwilliams Discrepancy with dummy argument attributes for\n  path between get and get_..._vec procedures #79 Small bug fix for CMake install #68 ( zbeekman ) JSON output files from tests are overwriting expected outputs and\n  outputs from other tests #86 ( zbeekman ) NAG Fortran Errors on module procedure :: change to module\n  procedure with no double colon PR #78 from kmanalo CMake for jf_test_9.f90 broke #74 ( zbeekman ) Merged pull requests: Very small changes and fixes: #81 ( zbeekman ) 3.1.0 (2015-02-28) Complete Changeset or Download v3.1.0 Enhancements: Compact real number printing ( 0.0 instead of 0.00000...E000 )\n  with ability to revert to old behavior #39 (implemented in PR #60 from zbeekman and PR #61 from jacobwilliams ) Read JSON structure from a character string #5 Adopted official contributing guidelines and added a CONTRIBUTING.md #47 Fixed issues: Build script ( build.sh ) failing with Intel's ifort #53 ,\n  fixed by PR #54 (from zbeekman ) Segfaults and unexpected behavior due to optional dummy arguments\n  being dereferenced outside of if (present(…)) #52 Documentation not being produced for tests because tests directory\n  should be sub-directory of src #49 Example 8 failing on gfortran 4.9.2 #44 CMake Tests 3 and 8 fail due to new test\n  case, example 6, added in e636f96 #30 CMake build using makefiles fails if\n  parallel build is specified #8 , fixed\n  by PR #50 from zbeekman Merged pull requests: Unit test updates #65 ( jacobwilliams ) Unit test cleanup as discussed in #30 #64 ( zbeekman ) Stops PRs by @jacobwilliams from\n  deploying master docs #62 ( zbeekman ) Auto deploy script #59 ( zbeekman ) Getting ready for auto-deployment #57 ( zbeekman ) Travis-CI build matrix #56 ( zbeekman ) 3.0.0 (2015-01-18) Complete Changeset or Download v3.0.0 Fixed issues: Intel compiler bug triggered by commit d2622a8 #41 Unaligned data warnings with Intel compiler #34 CMake fails due to bad path to robodoc.rc #31 Indentation of output wrong for some nested objects #29 Intel build broke #28 CMake misbehaving when ROBODoc absent #26 Differentiate internal (low level, private) procedures/types/etc\n  from public API in documentation #21 Merged pull requests: CMake Fixes for issues #31 and #26 . #32 ( zbeekman ) 2.0.0 (2014-12-27) Complete Changeset or Download v2.0.0 Enhancements: - Significant changes to the API including new procedures\n- Code re-factoring\n- SCons build added thanks to @bruceravel Fixed issues: enable wiki contributions from the public #23 1.0.0 (2014-06-23) Download v1.0.0 Enhancements: Validate hex values in strings #14 Add CMake build infrastructure #6 (pull request from zbeekman ) CMake build now builds the example program\n  and runs tests #9 Added CMake logic to build ROBODoc documentation #12 (pull\n  request from zbeekman ) Upload ROBODoc documentation to\n  gh-pages project page #7 Add CMake testing infrastructure #18 ( zbeekman ) Implement better support for Intel compiler, DPD200247629 associate construct work around, via PR #2 ( zbeekman ) Fixed issues: Unit tests fail when compiled with GFortran #19 CMake outputs of ROBODoc must be specified in\n  CMakeLists.txt manually #17 Invalid JSON input files ( test1.json , test5.json ) #10 ,\n  fixed by PR #11 ( zbeekman ) char() is processor dependent, use achar() #20 (pull request from zbeekman ) Bug-fix for ROBODoc documentation\n  generation with CMake #16 (pull request from zbeekman ) Change library file from libjson to libjsonfortran #4 * This Change Log was generated with help from github_changelog_generator Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . ↩","tags":"","loc":"page/releases/index.html","title":"Official Releases – JSON-Fortran"}]}